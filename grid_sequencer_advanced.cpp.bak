#include <iostream>
#include <string>
#include <thread>
#include <chrono>
#include <atomic>
#include <vector>
#include <array>
#include <sstream>
#include <iomanip>
#include <cmath>
#include <map>
#include <set>
#include <atomic>
#include <fstream>
#include <cstdlib>
#include <algorithm>
#include <random>
#include <termios.h>
#include <unistd.h>
#include <fcntl.h>
#include <cstring>
#include <errno.h>
#include <chrono>
// #include "encoder_control_system.h" // Removed - using simple direct approach

// Serial communication for encoder controller
class SerialPort {
private:
    int fd;
public:
    SerialPort() : fd(-1) {}

    bool open(const std::string& device) {
        fd = ::open(device.c_str(), O_RDWR | O_NOCTTY | O_NONBLOCK);
        if (fd == -1) return false;

        struct termios tty;
        if (tcgetattr(fd, &tty) != 0) return false;

        cfsetospeed(&tty, B115200);
        cfsetispeed(&tty, B115200);
        tty.c_cflag &= ~PARENB;
        tty.c_cflag &= ~CSTOPB;
        tty.c_cflag &= ~CSIZE;
        tty.c_cflag |= CS8;
        tty.c_cflag &= ~CRTSCTS;
        tty.c_cflag |= CREAD | CLOCAL;
        tty.c_lflag &= ~ICANON;
        tty.c_lflag &= ~ECHO;
        tty.c_lflag &= ~ECHOE;
        tty.c_lflag &= ~ECHONL;
        tty.c_lflag &= ~ISIG;
        tty.c_iflag &= ~(IXON | IXOFF | IXANY);
        tty.c_iflag &= ~(IGNBRK|BRKINT|PARMRK|ISTRIP|INLCR|IGNCR|ICRNL);
        tty.c_oflag &= ~OPOST;
        tty.c_oflag &= ~ONLCR;
        tty.c_cc[VTIME] = 1;
        tty.c_cc[VMIN] = 0;

        return tcsetattr(fd, TCSANOW, &tty) == 0;
    }

    int readData(char* buffer, int maxBytes) {
        if (fd == -1) return -1;
        return read(fd, buffer, maxBytes);
    }

    void close() {
        if (fd != -1) {
            ::close(fd);
            fd = -1;
        }
    }

    ~SerialPort() { close(); }
};

// Forward decls
bool isCurrentEngineDrum();
const char* getDisplayName(const char* technicalName);
#include <portaudio.h>
#include <lo/lo.h>
#include "src/core/Types.h"

// Forward declarations for real bridge functions
extern "C" {
    void* ether_create(void);
    void ether_destroy(void* synth);
    int ether_initialize(void* synth);
    void ether_process_audio(void* synth, float* outputBuffer, size_t bufferSize);
    void ether_play(void* synth);
    void ether_stop(void* synth);
    void ether_note_on(void* synth, int key_index, float velocity, float aftertouch);
    void ether_note_off(void* synth, int key_index);
    void ether_all_notes_off(void* synth);
    void ether_set_instrument_engine_type(void* synth, int instrument, int engine_type);
    int ether_get_instrument_engine_type(void* synth, int instrument);
    const char* ether_get_engine_type_name(int engine_type);
    int ether_get_engine_type_count();
    void ether_set_active_instrument(void* synth, int color_index);
    int ether_get_active_instrument(void* synth);
    int ether_get_active_voice_count(void* synth);
    float ether_get_cpu_usage(void* synth);
    void ether_set_master_volume(void* synth, float volume);
    float ether_get_master_volume(void* synth);
    void ether_set_instrument_parameter(void* synth, int instrument, int param_id, float value);
    float ether_get_instrument_parameter(void* synth, int instrument, int param_id);
    void ether_shutdown(void* synth);
    void ether_set_engine_voice_count(void* synth, int instrument, int voices);
    int ether_get_engine_voice_count(void* synth, int instrument);
    bool ether_engine_has_parameter(void* synth, int instrument, int param_id);
    float ether_get_memory_usage_kb(void* synth);
    float ether_get_cycles_480_per_buffer(void* synth);
    float ether_get_cycles_480_per_sample(void* synth);
    float ether_get_engine_cpu_pct(void* synth, int instrument);
    float ether_get_engine_cycles_480_buf(void* synth, int instrument);
    float ether_get_engine_cycles_480_smp(void* synth, int instrument);
    void ether_set_engine_fx_send(void* synth, int instrument, int which, float value);
    float ether_get_engine_fx_send(void* synth, int instrument, int which);
    void ether_set_fx_global(void* synth, int which, int param, float value);
    float ether_get_fx_global(void* synth, int which, int param);
    float ether_get_bpm(void* synth);
    int ether_get_parameter_lfo_info(void* synth, int instrument, int keyIndex, int* activeLFOs, float* currentValue);
    // LFO bridge
    // LFO controls (use active instrument internally)
    void ether_set_lfo_rate(void* synth, unsigned char lfo_id, float rate);
    void ether_set_lfo_depth(void* synth, unsigned char lfo_id, float depth);
    void ether_set_lfo_waveform(void* synth, unsigned char lfo_id, unsigned char waveform);
    void ether_set_lfo_sync(void* synth, int instrument, int lfoIndex, int syncMode);
    void ether_trigger_instrument_lfos(void* synth, int instrument);
    void ether_assign_lfo_to_param_id(void* synth, int instrument, int lfoIndex, int paramId, float depth);
    void ether_remove_lfo_assignment_by_param(void* synth, int instrument, int lfoIndex, int paramId);
}

const int MAX_ENGINES = 17;  // 13 real + 4 fallback = 17 total engines
const int GRID_WIDTH = 16;
const int GRID_HEIGHT = 8;
#ifndef BUILD_VERSION
#define BUILD_VERSION "Grid dev"
#endif
static const char* BUILD_VERSION_STR = BUILD_VERSION;

using ::ParameterID;

// Pseudo-parameters (not engine-backed)
static constexpr int PSEUDO_PARAM_OCTAVE = 999;
static constexpr int PSEUDO_PARAM_PITCH = 998;

std::map<int, std::string> parameterNames = {
    {static_cast<int>(ParameterID::HARMONICS), "harmonics"}, {static_cast<int>(ParameterID::TIMBRE), "timbre"}, {static_cast<int>(ParameterID::MORPH), "morph"},
    {static_cast<int>(ParameterID::OSC_MIX), "oscmix"}, {static_cast<int>(ParameterID::DETUNE), "detune"}, {static_cast<int>(ParameterID::SUB_LEVEL), "sublevel"}, {static_cast<int>(ParameterID::SUB_ANCHOR), "subanchor"},
    {static_cast<int>(ParameterID::FILTER_CUTOFF), "lpf"}, {static_cast<int>(ParameterID::FILTER_RESONANCE), "resonance"},
    {static_cast<int>(ParameterID::ATTACK), "attack"}, {static_cast<int>(ParameterID::DECAY), "decay"}, {static_cast<int>(ParameterID::SUSTAIN), "sustain"}, {static_cast<int>(ParameterID::RELEASE), "release"},
    // LFO controls are global, not engine parameters — omitted from engine param list
    {static_cast<int>(ParameterID::REVERB_SIZE), "reverb_size"}, {static_cast<int>(ParameterID::REVERB_DAMPING), "reverb_damp"}, {static_cast<int>(ParameterID::REVERB_MIX), "reverb_mix"},
    {static_cast<int>(ParameterID::DELAY_TIME), "delay_time"}, {static_cast<int>(ParameterID::DELAY_FEEDBACK), "delay_fb"},
    {static_cast<int>(ParameterID::VOLUME), "volume"}, {static_cast<int>(ParameterID::PAN), "pan"}, {static_cast<int>(ParameterID::HPF), "hpf"}, {static_cast<int>(ParameterID::ACCENT_AMOUNT), "accent"}, {static_cast<int>(ParameterID::GLIDE_TIME), "glide"},
    {static_cast<int>(ParameterID::AMPLITUDE), "amp"}, {static_cast<int>(ParameterID::CLIP), "clip"},
    // Pseudo-parameters (not engine-backed)
    {PSEUDO_PARAM_OCTAVE, "octave"},
    {PSEUDO_PARAM_PITCH, "pitch"}
};

// (moved method definitions appear near the end of this file)

// Global state
void* etherEngine = nullptr;
std::atomic<bool> audioRunning{false};
std::atomic<bool> playing{false};
std::atomic<bool> stepTrigger[MAX_ENGINES][16] = {};
std::atomic<bool> noteOffTrigger[MAX_ENGINES][16] = {};
std::atomic<int> currentStep{0};
std::atomic<int> activeNotes[MAX_ENGINES][16] = {};
// Suppress double-trigger when live-writing: remember previewed step
std::array<std::atomic<int>,16> drumPreviewStep;   // per pad: last step previewed
std::array<std::atomic<int>,MAX_ENGINES> melodicPreviewStep; // per engine: last step previewed
// Debounce pad presses within the 4x4 region
std::array<std::atomic<bool>,16> padIsDown; // true while key is held

// Step data per engine
struct StepData {
    bool active = false;
    int note = 60;
    float velocity = 0.6f;
    bool hasAccent = false;      // Accent mode flag
    bool hasRetrigger = false;   // Retrigger mode flag
    bool hasArpeggiator = false; // Arpeggiator mode flag
};

std::array<std::vector<StepData>, MAX_ENGINES> enginePatterns;
std::array<std::map<int, float>, MAX_ENGINES> engineParameters;
// Pattern bank storage - 64 patterns (4 banks of 16), each with MAX_ENGINES tracks
std::array<std::array<std::vector<StepData>, MAX_ENGINES>, 64> patternBank;

// Drum engine multi-lane pattern: per-drum 16-step bitmask
std::array<uint16_t, 16> drumMasks = {0};

// Minor scale
const std::vector<int> minorScale = {
    48, 50, 51, 53, 55, 56, 58, 59, 60, 62, 63, 65, 67, 68, 70, 72
};

// Grid OSC variables
lo_server_thread grid_server = nullptr;
lo_address grid_addr = nullptr;
std::atomic<int> currentEngineRow{0}; // Which engine we're editing/playing (0..MAX_ENGINES-1)
std::atomic<bool> gridConnected{false};
std::string grid_prefix = "/monome";
int local_grid_osc_port = 7001;

// 4x4 pad UI state
std::atomic<bool> writeMode{false};
std::atomic<bool> engineHold{false};
std::atomic<bool> shiftHeld{false};  // Advanced grid controller SHIFT key
std::atomic<bool> shiftEngineMode{false};  // SHIFT + ENGINE select mode
std::atomic<bool> patternHold{false};     // PATTERN button hold mode
std::atomic<int> currentPatternSlot{0};   // Current pattern slot (0-15)
std::atomic<int> currentPatternBank{0};   // Current pattern bank (0-3 for 4 banks of 16)
std::atomic<bool> chainingMode{false};    // Pattern chaining mode
std::vector<int> patternChain;            // Current pattern chain sequence
int lastLiveNote = -1;
int liveHeldNoteByPad[16];
std::atomic<bool> playAllEngines{true};
std::atomic<bool> accentLatch{false};
int selectedDrumPad = 0;

// Advanced mode system state variables
std::atomic<bool> copyMode{false};  // Copy mode enabled via function button
std::chrono::steady_clock::time_point copyPressTime;  // For long press detection
std::atomic<bool> retriggerMode{false};  // SHIFT + pad 11 retrigger mode
std::atomic<int> currentPage{0};  // Pattern pagination: 0-3 for pages 1-4 (16, 32, 48, 64 steps)
std::atomic<bool> accentMode{false};  // SHIFT + pad 15 accent mode
std::atomic<bool> deleteMode{false};  // DELETE mode enabled via button above Write
std::atomic<int> octaveOffset{0};  // SHIFT + pad 12/16 octave range (-4 to +4)
std::atomic<float> pitchOffset{0.0f};  // Continuous pitch offset in semitones (-12.0 to +12.0)
StepData copyBuffer;  // Buffer for copied step data
int copySourcePad = -1;  // Which pad was copied from (-1 = none)

// Retrigger Settings
enum class RetriggerTimingMode : int {
    STATIC = 0,          // Even spacing (current behavior)
    ACCELERATING,        // Roll - starts slow, gets faster
    DECELERATING,        // Fill - starts fast, slows down
    EXPONENTIAL,         // Dramatic acceleration curve
    LOGARITHMIC          // Dramatic deceleration curve
};

enum class RetriggerVelocityMode : int {
    STATIC = 0,          // Even velocity (current behavior)
    CRESCENDO,           // Gets louder
    DIMINUENDO,          // Gets quieter
    ACCENT_FIRST,        // First hit louder, others quiet
    ACCENT_LAST          // Last hit loudest
};

struct RetriggerSettings {
    int numTriggers = 3;                              // Number of triggers (1-8)
    int stepWindow = 1;                               // Number of steps for retrigger window (1-4)
    int octaveShift = 0;                              // Octave change across retrigger (-2 to +2)
    RetriggerTimingMode timingMode = RetriggerTimingMode::STATIC;    // Timing pattern
    RetriggerVelocityMode velocityMode = RetriggerVelocityMode::STATIC; // Velocity pattern
    float intensityCurve = 0.5f;                      // Curve intensity (0.0-1.0)
};
std::atomic<bool> retriggerSettingsMode{false};  // Show retrigger settings menu
RetriggerSettings retriggerSettings;
int retriggerSettingsIndex = 0;  // Current setting being edited (0=triggers, 1=window, 2=octave, 3=timing, 4=velocity, 5=curve)

// Arpeggiator Settings
enum class ArpPattern : int {
    UP = 0,          // C E G C E G...
    DOWN,            // C G E C G E...
    UP_DOWN,         // C E G E C E G E...
    DOWN_UP,         // C G E G C G E G...
    RANDOM,          // Random order
    AS_PLAYED,       // Order notes were played in
    CHORD           // All notes together (chord mode)
};

struct ArpeggiatorSettings {
    ArpPattern pattern = ArpPattern::UP;  // Arpeggiator pattern
    int length = 3;                       // Number of notes in arp (1-8)
    int cycles = -1;                      // Number of cycles (-1 = infinite/latch)
    int octaveRange = 1;                  // Octave range (1-4)
    int speed = 4;                        // Speed multiplier (1=1/16, 2=1/8, 4=1/4, 8=1/2, 16=whole)
    int gateLength = 75;                  // Gate length percentage (25-100%)
};

std::atomic<bool> arpeggiatorMode{false};         // SHIFT + pad 10 arpeggiator mode
std::atomic<bool> arpeggiatorSettingsMode{false}; // Show arpeggiator settings menu
ArpeggiatorSettings arpeggiatorSettings;
int arpeggiatorSettingsIndex = 0;  // Current setting being edited (0=pattern, 1=length, 2=cycles, 3=octaves, 4=speed, 5=gate)

// Pattern Gate Settings - Unified gate/stutter + probability effect
enum class PatternGateMode : int {
    DETERMINISTIC = 0,   // Fixed on/off pattern
    PROBABILISTIC,       // Each step has % chance to trigger
    HYBRID              // Pattern modified by probability
};

struct PatternGateSettings {
    PatternGateMode mode = PatternGateMode::DETERMINISTIC;
    uint16_t pattern = 0b1010101010101010;                   // 16-step on/off pattern (bit 0 = step 1, bit 15 = step 16)
    float probability = 0.75f;                                // Global probability (0.0-1.0)
    int resolution = 1;                                       // Subdivision: 1=/16, 2=/8, 4=/4, 8=/2, 16=whole
    float swing = 0.0f;                                       // Timing humanization (-0.5 to +0.5)
    bool enabled = false;                                     // Pattern gate active
};
std::atomic<bool> patternGateSettingsMode{false};            // Show pattern gate settings menu
PatternGateSettings patternGateSettings;
int patternGateSettingsIndex = 0;                            // Current setting being edited (0=mode, 1=pattern, 2=probability, 3=resolution, 4=swing)

// Performance Effects System - Real-time Pattern and Audio Manipulation
enum class PerformanceFX : int {
    LOOP_16 = 0,         // loops & retriggers 16th note segments
    LOOP_12,             // loops & retriggers 12th note segments
    LOOP_SHORT,          // loops & retriggers 32nd note segments
    LOOP_SHORTER,        // loops & retriggers 48th note segments
    LOOP_16_DOUBLE,      // double-time loop 16th note segments
    LOOP_12_DOUBLE,      // double-time loop 12th note segments
    LOOP_SHORT_DOUBLE,   // double-time loop 32nd note segments
    LOOP_SHORTER_DOUBLE, // double-time loop 48th note segments
    STUTTER_SWEEP,       // volume tremolo & filter sweep
    TRANCE_GATE,         // stepped gate that chops the sound
    HALF_RATE,           // halves speed and pitch
    BUILD_UP_16_BAR,     // ramps up pitch over 16 bars
    QUANTIZE_6_8,        // quantizes from 4/4 to 6/8
    RETRIGGER_PATTERN,   // randomly rearranges sequence
    REVERSE,             // plays audio in reverse (real-time buffer reversal)
    SCRATCH              // ping-pong scratch effect over 4 beats
};

const std::array<std::string, 16> PERFORMANCE_FX_NAMES = {
    "Loop 16", "Loop 12", "Loop Short", "Loop Shorter",
    "Loop 16 2x", "Loop 12 2x", "Loop Short 2x", "Loop Shorter 2x",
    "Stutter Sweep", "Trance Gate", "Half Rate", "16 Bar Build Up",
    "6/8 Quantize", "Retrigger Pattern", "Reverse", "Scratch"
};

struct PerformanceFXState {
    // Support multiple simultaneous effects
    std::set<PerformanceFX> activeEffects;
    std::map<PerformanceFX, float> effectIntensities;  // Per-effect intensity 0.0-1.0

    bool hasActiveEffects() const { return !activeEffects.empty(); }

    // Add/remove effects for stacking
    void activateEffect(PerformanceFX effect, float intensity = 1.0f) {
        activeEffects.insert(effect);
        effectIntensities[effect] = intensity;
    }

    void deactivateEffect(PerformanceFX effect) {
        activeEffects.erase(effect);
        effectIntensities.erase(effect);
    }

    void clearAllEffects() {
        activeEffects.clear();
        effectIntensities.clear();
    }

    bool isEffectActive(PerformanceFX effect) const {
        return activeEffects.find(effect) != activeEffects.end();
    }

    // Timing state for pattern manipulation (shared across effects)
    int stepCounter = 0;
    int loopLength = 4;      // in steps
    int loopPosition = 0;
    int stutterCounter = 0;
    int scratchPosition = 0;
    bool scratchDirection = true;

    // Pattern backup for reversible effects
    std::array<std::array<StepData, 16>, MAX_ENGINES> originalPattern;
    std::array<int, 16> shuffledStepOrder;

    // Effect-specific parameters (shared/combined when stacking)
    float pitchShift = 1.0f;  // For octave effects
    bool patternReversed = false;
    int quantizeDivision = 4; // For 6/8 quantize

    // Timing synchronization
    std::chrono::steady_clock::time_point lastTrigger;
    double stepInterval = 0.125; // 8th note in seconds at 120 BPM
};

PerformanceFXState performanceFX;

// FX system is now fully global
bool fxModeActive = false;

// Pseudo-parameter LFO assignments (since they can't use engine LFO system)
struct PseudoParamLFO {
    bool active = false;
    int lfoIndex = -1;  // Which LFO (0-7)
    float depth = 0.5f;
    std::chrono::steady_clock::time_point lastUpdate;
};

std::map<int, PseudoParamLFO> pseudoParamLFOs; // Maps pseudo param ID to LFO assignment

// Map engine rows to instrument slots (0..7). -1 = unmapped
int rowToSlot[MAX_ENGINES];
int slotToRow[16];
bool rowMuted[MAX_ENGINES] = {false};
int soloEngine = -1; // -1 = no solo
bool muteHold = false;
std::chrono::steady_clock::time_point lastMutePress;

// UI requests from OSC handler (handled on engine thread)
std::atomic<bool> reqTogglePlay{false};
std::atomic<bool> reqClear{false};

// Terminal UI state
std::atomic<int> selectedParamIndex{0};
static int selectedLFOIndex = 0; // 0..7
static int lfoWaveform[8] = {0};
static float lfoRate[8] = {1,1,1,1,1,1,1,1};
static float lfoDepth[8] = {0.5f,0.5f,0.5f,0.5f,0.5f,0.5f,0.5f,0.5f};
static bool showLFOAssign = false;
static bool showLFOSettings = false;
static int lfoAssignCursor = 0; // 0..7 within assign row
static uint32_t lfoAssignMask = 0; // local UI mirror of assignments for current parameter (lower 8 bits)
std::vector<ParameterID> uiParams = {
    // Core synth & env
    ParameterID::HARMONICS, ParameterID::TIMBRE, ParameterID::MORPH,
    ParameterID::ATTACK, ParameterID::DECAY, ParameterID::SUSTAIN, ParameterID::RELEASE,
    // Tone & mix
    ParameterID::FILTER_CUTOFF, ParameterID::FILTER_RESONANCE, ParameterID::HPF,
    ParameterID::VOLUME, ParameterID::PAN, ParameterID::AMPLITUDE, ParameterID::CLIP,
    // Performance
    ParameterID::ACCENT_AMOUNT, ParameterID::GLIDE_TIME
};
// Computed each frame based on current engine support
std::vector<ParameterID> visibleParams;
// Extended visible params including pseudo-parameters
std::vector<int> extendedVisibleParams;

// Number of non-engine-parameter rows shown after the main parameter list:
//  voices (1) + per-engine sends (2) + global reverb (3) + global delay (3) = 9
static inline int extraMenuRows() {
    int extra = 9;
    if (isCurrentEngineDrum()) extra += 1; // drum edit row
    return extra;
}

// Helper: current row's instrument engine type name
static inline const char* currentInstrumentTypeName() {
    int slot = rowToSlot[currentEngineRow];
    if (slot < 0) slot = 0;
    int t = ether_get_instrument_engine_type(etherEngine, slot);
    return ether_get_engine_type_name(t);
}

static void rebuildVisibleParams() {
    visibleParams.clear();
    extendedVisibleParams.clear();

    int slot = rowToSlot[currentEngineRow]; if (slot < 0) slot = 0;
    for (auto pid : uiParams) {
        int pidInt = static_cast<int>(pid);
        // Always show global post filters
        if (pid == ParameterID::FILTER_CUTOFF || pid == ParameterID::FILTER_RESONANCE || pid == ParameterID::HPF) {
            visibleParams.push_back(pid);
            extendedVisibleParams.push_back(pidInt);
            continue;
        }
        // Query engine support for others
        if (ether_engine_has_parameter(etherEngine, slot, pidInt)) {
            visibleParams.push_back(pid);
            extendedVisibleParams.push_back(pidInt);
        }
    }

    // Add pseudo-parameters for melodic engines
    if (!isCurrentEngineDrum()) {
        extendedVisibleParams.push_back(PSEUDO_PARAM_OCTAVE);
        extendedVisibleParams.push_back(PSEUDO_PARAM_PITCH);
    }

    // Clamp selection index to full menu range (extended params + extras)
    int maxIndex = static_cast<int>(extendedVisibleParams.size()) + extraMenuRows();
    if (selectedParamIndex < 0) selectedParamIndex = 0;
    if (selectedParamIndex > maxIndex) selectedParamIndex = maxIndex;
}

// Drum edit UI state
int drumEditPad = 0; // 0..15
int drumEditField = 0; // 0=decay,1=tune,2=level,3=pan

extern "C" {
    void ether_drum_set_param(void* synth, int instrument, int pad, int which, float value);
}

// Forward declarations for pattern bank helpers
int getAbsolutePatternIndex(int bank, int slot);
int getCurrentAbsolutePatternIndex();

// Terminal raw mode helpers
termios orig_termios;
void disableRawMode() {
    tcsetattr(STDIN_FILENO, TCSAFLUSH, &orig_termios);
}
void enableRawMode() {
    tcgetattr(STDIN_FILENO, &orig_termios);
    termios raw = orig_termios;
    raw.c_lflag &= ~(ECHO | ICANON);
    raw.c_cc[VMIN] = 0;
    raw.c_cc[VTIME] = 1; // 100ms timeout
    tcsetattr(STDIN_FILENO, TCSAFLUSH, &raw);
}

void setStdinNonblocking() {
    int flags = fcntl(STDIN_FILENO, F_GETFL, 0);
    fcntl(STDIN_FILENO, F_SETFL, flags | O_NONBLOCK);
}

void applyParamToEngine(int engine, ParameterID pid, float value) {
    value = std::max(0.0f, std::min(1.0f, value));
    engineParameters[engine][static_cast<int>(pid)] = value;
    if (etherEngine) {
        int slot = (engine >= 0 && engine < MAX_ENGINES) ? rowToSlot[engine] : 0;
        if (slot < 0) slot = 0;
        ether_set_active_instrument(etherEngine, slot);
        ether_set_instrument_parameter(etherEngine, slot, static_cast<int>(pid), value);
    }
}

// Get parameter value, including pseudo-parameters
float getExtendedParameterValue(int paramId, int slot) {
    if (paramId == PSEUDO_PARAM_OCTAVE) {
        // Convert octave offset (-4 to +4) to normalized 0-1 range
        return (octaveOffset.load() + 4.0f) / 8.0f;
    } else if (paramId == PSEUDO_PARAM_PITCH) {
        // Convert pitch offset (-12.0 to +12.0) to normalized 0-1 range
        return (pitchOffset.load() + 12.0f) / 24.0f;
    } else {
        return ether_get_instrument_parameter(etherEngine, slot, paramId);
    }
}

// Set parameter value, including pseudo-parameters
void setExtendedParameterValue(int paramId, int slot, float value) {
    if (paramId == PSEUDO_PARAM_OCTAVE) {
        // Convert normalized 0-1 range to octave offset (-4 to +4)
        octaveOffset = static_cast<int>((value * 8.0f) - 4.0f);
        octaveOffset = std::max(-4, std::min(4, octaveOffset.load()));
    } else if (paramId == PSEUDO_PARAM_PITCH) {
        // Convert normalized 0-1 range to pitch offset (-12.0 to +12.0)
        pitchOffset = (value * 24.0f) - 12.0f;
        pitchOffset = std::max(-12.0f, std::min(12.0f, pitchOffset.load()));
    } else {
        ether_set_instrument_parameter(etherEngine, slot, paramId, value);
    }
}

// Get the parameter ID from the extended parameter list, handling pseudo-parameters
int getExtendedParameterId(int index) {
    if (index >= 0 && index < (int)extendedVisibleParams.size()) {
        return extendedVisibleParams[index];
    }
    return -1; // Invalid
}

// Clean, centralized parameter adjustment function
void adjustParameter(int pid, bool increment) {
    // Handle pseudo-parameters
    if (pid == PSEUDO_PARAM_OCTAVE) {
        if (increment) {
            octaveOffset = std::min(4, octaveOffset.load() + 1);
        } else {
            octaveOffset = std::max(-4, octaveOffset.load() - 1);
        }
        return;
    } else if (pid == PSEUDO_PARAM_PITCH) {
        if (increment) {
            pitchOffset = std::min(12.0f, pitchOffset.load() + 0.5f);
        } else {
            pitchOffset = std::max(-12.0f, pitchOffset.load() - 0.5f);
        }
        return;
    }

    // Regular engine parameters - get current value from engine
    int slot = rowToSlot[currentEngineRow];
    if (slot < 0) slot = 0;
    float currentValue = ether_get_instrument_parameter(etherEngine, slot, pid);

    // Special handling for FM algorithm (TIMBRE parameter)
    int engType = ether_get_instrument_engine_type(etherEngine, slot);
    const char* etn = ether_get_engine_type_name(engType);
    bool fm = (etn && std::string(etn).find("FM") != std::string::npos);
    if (pid == static_cast<int>(ParameterID::TIMBRE) && fm) {
        int algo = (int)std::floor(currentValue * 8.0f + 1e-6);
        if (increment) {
            algo = std::min(7, algo + 1);
        } else {
            algo = std::max(0, algo - 1);
        }
        currentValue = (algo + 0.5f) / 8.0f;
    } else {
        // ALWAYS work in normalized 0..1 domain for UI steps; engine maps to Hz/Q/etc.
        float delta = 0.02f; // default
        if (pid == static_cast<int>(ParameterID::FILTER_CUTOFF) ||
            pid == static_cast<int>(ParameterID::HPF)) {
            // small smooth steps; SHIFT speeds up
            delta = shiftHeld.load() ? 0.05f : 0.01f;
        } else if (pid == static_cast<int>(ParameterID::FILTER_RESONANCE)) {
            delta = 0.01f;
        } else if (pid == static_cast<int>(ParameterID::AMPLITUDE) ||
                   pid == static_cast<int>(ParameterID::CLIP)) {
            delta = 0.02f;
        }

        if (increment) {
            currentValue += delta;
        } else {
            currentValue -= delta;
        }
        // Clamp to normalized range expected by engine
        currentValue = clamp(currentValue, 0.0f, 1.0f);
    }

    // Set the new value directly to the engine
    printf("DEBUG: Setting pid=%d to value=%.3f\n", pid, currentValue);
    ether_set_instrument_parameter(etherEngine, slot, pid, currentValue);

    // Verify the value was set
    float verifyValue = ether_get_instrument_parameter(etherEngine, slot, pid);
    printf("DEBUG: Verified value=%.3f\n", verifyValue);
    // Keep local cache coherent for UI reads
    engineParameters[currentEngineRow][pid] = verifyValue;
}

void drawFixedUI() {
    // Clear screen and home cursor
    printf("\x1b[2J\x1b[H");
    rebuildVisibleParams();
    // Use friendly display name
    const char* techName = currentInstrumentTypeName();
    const char* name = getDisplayName(techName);
    const char* cat = nullptr;
    float cpu = ether_get_cpu_usage(etherEngine);
    float memMB = ether_get_memory_usage_kb(etherEngine) / 1024.0f;
    float cycBuf = ether_get_cycles_480_per_buffer(etherEngine);
    float cycSmp = ether_get_cycles_480_per_sample(etherEngine);
    // Pattern bank and chaining status
    int absolutePattern = getCurrentAbsolutePatternIndex();
    const char* chainingStatus = chainingMode.load() ? " | CHAINING" : "";
    const char* patternStatus = patternHold.load() ? " | PATTERN" : "";

    printf("Ether Grid Sequencer | %s | Engine: %d %s%s%s%s | BPM: %3.0f | %s | Bank %d/4 Pattern %d%s%s | CPU: %4.1f%% | MEM: %4.1f MB\n",
           BUILD_VERSION_STR,
           currentEngineRow.load(),
           name ? name : "?",
           cat ? " [" : "",
           cat ? cat : "",
           cat ? "]" : "",
           ether_get_bpm(etherEngine),
           playing ? "PLAY" : "STOP",
           currentPatternBank.load() + 1,
           absolutePattern + 1,
           chainingStatus,
           patternStatus,
           cpu, memMB);
    // Per-slot CPU% line (first 8 slots)
    printf("CPU slots: ");
    for (int s=0;s<8;s++){ float p = ether_get_engine_cpu_pct(etherEngine, s); printf("%d:%3.0f%% ", s, p); }
    printf("\n");

    // Mode status indicators
    printf("Modes: ");
    if (!isCurrentEngineDrum()) {
        printf("OCT:%+d ", octaveOffset.load());
    }
    printf("%s%s%s%s%s%s\n",
           accentMode ? "ACCENT " : "",
           retriggerMode ? "RETRIG " : "",
           arpeggiatorMode ? "ARP " : "",
           patternGateSettings.enabled ? "GATE " : "",
           copyMode ? "COPY " : "",
           (accentMode || retriggerMode || arpeggiatorMode || patternGateSettings.enabled || copyMode || octaveOffset != 0) ? "" : "NONE");
    
    // Show FM algo if applicable (uses TIMBRE as algo selector 0..7)
    int algo = (int)std::floor(engineParameters[currentEngineRow][static_cast<int>(ParameterID::TIMBRE)] * 8.0f);
    if (algo < 0) algo = 0; if (algo > 7) algo = 7;
    bool isFM = (currentInstrumentTypeName() && std::string(currentInstrumentTypeName()).find("FM") != std::string::npos);
    if (isFM) {
        static const char* fmAlgoNames[8] = {
            "Stack 1-2-3-4", "Stack 1-2-2-3", "Bright 1-3-2-5", "Mellow 1-1.5-2-3",
            "FB 1-2-1-2", "Sub 0.5-1-2-3", "Clang 1-2.5-3.5-5", "Organ 1-1-1-1"
        };
        printf("FM Algo: %d/8 - %s (TIMBRE)\n", algo+1, fmAlgoNames[algo]);
    } else {
        printf("\n");
    }

    // Retrigger settings display
    if (retriggerSettingsMode.load()) {
        // Display names for timing modes
        const char* timingModeNames[] = {"Static", "Accel", "Decel", "Exponential", "Logarithmic"};
        const char* velocityModeNames[] = {"Static", "Crescendo", "Diminuendo", "Accent First", "Accent Last"};

        printf("╭─ RETRIGGER SETTINGS ────────────────────────────────────────────────────────╮\n");
        printf("│ %s Triggers:    %d     (1-8 triggers per step)                            │\n",
               retriggerSettingsIndex == 0 ? "►" : " ", retriggerSettings.numTriggers);
        printf("│ %s Step Window: %d     (spread over 1-4 steps)                            │\n",
               retriggerSettingsIndex == 1 ? "►" : " ", retriggerSettings.stepWindow);
        printf("│ %s Octave Shift:%+2d    (octave change across retrigger)                  │\n",
               retriggerSettingsIndex == 2 ? "►" : " ", retriggerSettings.octaveShift);
        printf("│ %s Timing:      %-11s (roll/fill patterns)                         │\n",
               retriggerSettingsIndex == 3 ? "►" : " ", timingModeNames[static_cast<int>(retriggerSettings.timingMode)]);
        printf("│ %s Velocity:    %-11s (volume patterns)                            │\n",
               retriggerSettingsIndex == 4 ? "►" : " ", velocityModeNames[static_cast<int>(retriggerSettings.velocityMode)]);
        printf("│ %s Curve:       %.1f       (curve intensity 0.0-1.0)                     │\n",
               retriggerSettingsIndex == 5 ? "►" : " ", retriggerSettings.intensityCurve);
        printf("╰─ Press T to toggle menu, ↑/↓ to select, ←/→ to adjust ──────────────────────╯\n");
        printf("\n");
    }

    // Arpeggiator settings display
    if (arpeggiatorSettingsMode.load()) {
        // Pattern names for display
        const char* patternNames[] = {"Up", "Down", "Up-Down", "Down-Up", "Random", "As-Played", "Chord"};
        const char* speedNames[] = {"1/16", "1/8", "1/4", "1/2", "Whole"};
        int speedIndex = 0;
        if (arpeggiatorSettings.speed == 1) speedIndex = 0;
        else if (arpeggiatorSettings.speed == 2) speedIndex = 1;
        else if (arpeggiatorSettings.speed == 4) speedIndex = 2;
        else if (arpeggiatorSettings.speed == 8) speedIndex = 3;
        else if (arpeggiatorSettings.speed == 16) speedIndex = 4;

        printf("╭─ ARPEGGIATOR SETTINGS ──────────────────────────────────────────────────────╮\n");
        printf("│ %s Pattern:     %-8s (arp note order)                                 │\n",
               arpeggiatorSettingsIndex == 0 ? "►" : " ", patternNames[static_cast<int>(arpeggiatorSettings.pattern)]);
        printf("│ %s Length:      %d        (notes in arpeggio 1-8)                       │\n",
               arpeggiatorSettingsIndex == 1 ? "►" : " ", arpeggiatorSettings.length);
        printf("│ %s Cycles:      %-8s (repeats, -1=infinite)                          │\n",
               arpeggiatorSettingsIndex == 2 ? "►" : " ", arpeggiatorSettings.cycles == -1 ? "infinite" : std::to_string(arpeggiatorSettings.cycles).c_str());
        printf("│ %s Octaves:     %d        (octave range 1-4)                           │\n",
               arpeggiatorSettingsIndex == 3 ? "►" : " ", arpeggiatorSettings.octaveRange);
        printf("│ %s Speed:       %-8s (note speed)                                     │\n",
               arpeggiatorSettingsIndex == 4 ? "►" : " ", speedNames[speedIndex]);
        printf("│ %s Gate:        %d%%       (note length 25-100%%)                       │\n",
               arpeggiatorSettingsIndex == 5 ? "►" : " ", arpeggiatorSettings.gateLength);
        printf("╰─ Press A to toggle menu, ↑/↓ to select, ←/→ to adjust ──────────────────────╯\n");
        printf("\n");
    }

    // Pattern Gate settings display
    if (patternGateSettingsMode.load()) {
        // Display names for modes and resolutions
        const char* modeNames[] = {"Deterministic", "Probabilistic", "Hybrid"};
        const char* resolutionNames[] = {"1/16", "1/8", "1/4", "1/2", "Whole"};
        int resolutionIndex = 0;
        if (patternGateSettings.resolution == 1) resolutionIndex = 0;
        else if (patternGateSettings.resolution == 2) resolutionIndex = 1;
        else if (patternGateSettings.resolution == 4) resolutionIndex = 2;
        else if (patternGateSettings.resolution == 8) resolutionIndex = 3;
        else if (patternGateSettings.resolution == 16) resolutionIndex = 4;

        // Convert pattern to readable string (show first 8 bits for brevity)
        std::string patternStr = "";
        for (int i = 7; i >= 0; i--) {
            patternStr += (patternGateSettings.pattern & (1 << i)) ? "■" : "□";
        }

        printf("╭─ PATTERN GATE SETTINGS ─────────────────────────────────────────────────────╮\n");
        printf("│ %s Mode:        %-12s (gate/stutter + probability)                  │\n",
               patternGateSettingsIndex == 0 ? "►" : " ", modeNames[static_cast<int>(patternGateSettings.mode)]);
        printf("│ %s Pattern:     %s      (16-step on/off pattern)                      │\n",
               patternGateSettingsIndex == 1 ? "►" : " ", patternStr.c_str());
        printf("│ %s Probability: %.0f%%       (chance each step triggers)                 │\n",
               patternGateSettingsIndex == 2 ? "►" : " ", patternGateSettings.probability * 100.0f);
        printf("│ %s Resolution:  %-8s (timing subdivision)                          │\n",
               patternGateSettingsIndex == 3 ? "►" : " ", resolutionNames[resolutionIndex]);
        printf("│ %s Swing:       %+.1f      (timing humanization -0.5 to +0.5)          │\n",
               patternGateSettingsIndex == 4 ? "►" : " ", patternGateSettings.swing);
        printf("╰─ Press G to toggle menu, ↑/↓ to select, ←/→ to adjust ──────────────────────╯\n");
        printf("\n");
    }

    // Parameter table (no scroll) - now includes pseudo-parameters
    printf("Params (↑/↓ select, ←/→ adjust, space play/stop, w write, c clear, q quit)\n");
    int slot = rowToSlot[currentEngineRow]; if (slot < 0) slot = 0;
    for (size_t i = 0; i < extendedVisibleParams.size(); ++i) {
        int paramId = extendedVisibleParams[i];
        float v = getExtendedParameterValue(paramId, slot);
        const char* sel = (selectedParamIndex == (int)i) ? ">" : " ";
        std::string label = parameterNames[paramId];

        // Special formatting for pseudo-parameters
        if (paramId == PSEUDO_PARAM_OCTAVE) {
            printf("%s %-12s : %+d\n", sel, label.c_str(), octaveOffset.load());
        } else if (paramId == PSEUDO_PARAM_PITCH) {
            printf("%s %-12s : %+.1f st\n", sel, label.c_str(), pitchOffset.load());
        } else {
            // Rename LPF cutoff to "brightness" for Classic 4-Op FM
            bool isFM4Op = (currentInstrumentTypeName() && std::string(currentInstrumentTypeName()).find("Classic4OpFM") != std::string::npos);
            if (isFM4Op && paramId == static_cast<int>(ParameterID::FILTER_CUTOFF)) label = "brightness";
            printf("%s %-12s : %0.2f\n", sel, label.c_str(), v);
        }
    }
    // Extra: Voices control + FX controls
    int baseIdx = (int)extendedVisibleParams.size();
    int voices = ether_get_engine_voice_count(etherEngine, 0);
    const char* selv = (selectedParamIndex == baseIdx) ? ">" : " ";
    printf("%s %-12s : %d\n", selv, "voices", voices);
    // Per-engine FX sends
    float sRev = ether_get_engine_fx_send(etherEngine, currentEngineRow, 0);
    float sDel = ether_get_engine_fx_send(etherEngine, currentEngineRow, 1);
    const char* sels1 = (selectedParamIndex == baseIdx+1) ? ">" : " ";
    const char* sels2 = (selectedParamIndex == baseIdx+2) ? ">" : " ";
    printf("%s %-12s : %0.2f\n", sels1, "rev_send", sRev);
    printf("%s %-12s : %0.2f\n", sels2, "del_send", sDel);
    // Global FX
    float rvTime = ether_get_fx_global(etherEngine, 0, 0);
    float rvDamp = ether_get_fx_global(etherEngine, 0, 1);
    float rvMix  = ether_get_fx_global(etherEngine, 0, 2);
    float dlTime = ether_get_fx_global(etherEngine, 1, 0);
    float dlFB   = ether_get_fx_global(etherEngine, 1, 1);
    float dlMix  = ether_get_fx_global(etherEngine, 1, 2);
    const char* selg0 = (selectedParamIndex == baseIdx+3) ? ">" : " ";
    const char* selg1 = (selectedParamIndex == baseIdx+4) ? ">" : " ";
    const char* selg2 = (selectedParamIndex == baseIdx+5) ? ">" : " ";
    const char* selg3 = (selectedParamIndex == baseIdx+6) ? ">" : " ";
    const char* selg4 = (selectedParamIndex == baseIdx+7) ? ">" : " ";
    const char* selg5 = (selectedParamIndex == baseIdx+8) ? ">" : " ";
    printf("%s %-12s : %0.2f\n", selg0, "rvb_size", rvTime);
    printf("%s %-12s : %0.2f\n", selg1, "rvb_damp", rvDamp);
    printf("%s %-12s : %0.2f\n", selg2, "rvb_mix",  rvMix);
    printf("%s %-12s : %0.2f\n", selg3, "dly_time", dlTime);
    printf("%s %-12s : %0.2f\n", selg4, "dly_fb",   dlFB);
    printf("%s %-12s : %0.2f\n", selg5, "dly_mix",  dlMix);
    // LFO quick status
    printf("LFO sel: %2d  wf=%2d  rate=%4.2fHz  depth=%4.2f  ([/]=select  v=wave  r/R=rate  d/D=depth  L=assign menu  S=settings)\n",
           selectedLFOIndex+1, lfoWaveform[selectedLFOIndex], lfoRate[selectedLFOIndex], lfoDepth[selectedLFOIndex]);

    if (showLFOAssign) {
        printf("\nLFO Assign — toggle with X, arrows move, L to close\n");
        for (int idx=0; idx<8; ++idx) {
            bool on = (lfoAssignMask >> idx) & 1u;
            bool sel = (lfoAssignCursor == idx);
            printf("%s[%c]%2d ", sel?">":" ", on?'x':' ', idx+1);
        }
        printf("\n");
    }

    if (showLFOSettings) {
        printf("\nLFO Settings — %2d  wf=%d  rate=%4.2fHz  depth=%4.2f  (v/r/R/d/D/k=KeySync e=Env)\n",
               selectedLFOIndex+1, lfoWaveform[selectedLFOIndex], lfoRate[selectedLFOIndex], lfoDepth[selectedLFOIndex]);
    }
    printf("  play mode     : %s (press 'a' to toggle)\n", playAllEngines ? "ALL" : "CURRENT");
    // Mute/Solo
    printf("  mute/solo     : hold grid y0x4 for mute view; double-tap to solo current row\n");
    size_t idxAfter = uiParams.size()+1;
    if (isCurrentEngineDrum()) {
        const char* seld = (selectedParamIndex == (int)idxAfter) ? ">" : " ";
        const char* fieldNames[4] = {"decay","tune","level","pan"};
        printf("%s drum pad    : %d\n", seld, drumEditPad);
        printf("  edit field   : %s\n", fieldNames[drumEditField]);
        printf("  tip: press a drum pad to select; enter cycles field\n");
        printf("  ←/→ adjust, [/] pad-, ] pad+  (level/pan 0..1, tune -1..1)\n");
    }
    
    // Pattern line
    printf("\nPattern: ");
    for (int i = 0; i < 16; ++i) {
        bool on = enginePatterns[currentEngineRow][i].active;
        if (playing && i == currentStep) {
            printf("[%c]", on ? '#' : '.');
        } else {
            printf(" %c ", on ? '#' : '.');
        }
    }
    printf("\n");

    // Pattern chain display when in chaining mode
    if (chainingMode.load() && !patternChain.empty()) {
        printf("Chain: ");
        for (size_t i = 0; i < patternChain.size(); i++) {
            if (i > 0) printf(" → ");
            printf("%d", patternChain[i] + 1);
        }
        printf("  [Click PATTERN to finish chain]\n");
    }

        if (isCurrentEngineDrum()) {
            printf("Drum hits at step %2d: ", currentStep.load()+1);
            for (int pad = 0; pad < 16; ++pad) {
                bool on = (drumMasks[pad] >> currentStep) & 1u;
                printf("%c", on ? '#' : '.');
            }
            printf("\n");
        }
    fflush(stdout);
}

bool isCurrentEngineDrum() {
    const char* name = currentInstrumentTypeName();
    if (!name) return false;
    std::string n(name);
    for (auto &c : n) c = std::tolower(c);
    return n.find("drum") != std::string::npos;
}

bool isEngineDrum(int row) {
    int slot = rowToSlot[row];
    if (slot < 0) slot = 0;
    int t = ether_get_instrument_engine_type(etherEngine, slot);
    const char* name = ether_get_engine_type_name(t);
    if (!name) return false;
    std::string n(name);
    for (auto &c : n) c = std::tolower(c);
    return n.find("drum") != std::string::npos;
}

const char* getDisplayName(const char* technicalName) {
    if (!technicalName) return "Unknown";
    
    static const std::map<std::string, const char*> displayNames = {
        {"MacroVA", "Analog VA"},
        {"MacroFM", "FM Synth"},
        {"MacroWaveshaper", "Waveshaper"},
        {"MacroWavetable", "Wavetable"},
        {"MacroChord", "Multi-Voice"},
        {"MacroHarmonics", "Morph"},
        {"FormantVocal", "Vocal"},
        {"NoiseParticles", "Noise"},
        {"TidesOsc", "Morph"},
        {"RingsVoice", "Modal"},
        {"ElementsVoice", "Exciter"},
        {"SlideAccentBass", "Acid"},
        {"Classic4OpFM", "Classic FM"},
        {"Granular", "Granular"},
        {"DrumKit(fallback)", "Drum Kit"},
        {"SamplerKit(fallback)", "Sampler"},
        {"SamplerSlicer(fallback)", "Sampler"},
        {"SerialHPLP(fallback)", "Filter"}
    };
    
    auto it = displayNames.find(technicalName);
    return (it != displayNames.end()) ? it->second : technicalName;
}

// General MIDI-ish 16-pad map: K S Rim Clap Toms HH Crash Ride
const std::array<int,16> DRUM_PAD_NOTES = {
    36, // 0 Kick A (Bass Drum 1)
    38, // 1 Snare A (Acoustic Snare)
    49, // 2 Crash Cymbal 1
    39, // 3 Hand Clap
    41, // 4 Low Tom
    45, // 5 Mid Tom
    48, // 6 High Tom
    37, // 7 Rimshot / Side Stick
    42, // 8 Closed Hat
    44, // 9 Pedal Hat
    46, // 10 Open Hat
    51, // 11 Ride Cymbal 1
    56, // 12 Cowbell
    35, // 13 Kick B (Acoustic Bass Drum)
    40, // 14 Snare B (Electric Snare)
    70  // 15 Shaker (Maracas)
};

// Forward declare
void bakePerformanceFXIntoPattern(PerformanceFX effect);

void register_grid_with_device(int device_port) {
    if (grid_addr) {
        lo_address_free(grid_addr);
        grid_addr = nullptr;
    }
    grid_addr = lo_address_new("127.0.0.1", std::to_string(device_port).c_str());
    if (!grid_addr) {
        std::cout << "Grid: failed to create address for device port " << device_port << std::endl;
        return;
    }
    // sys messages are NOT prefixed
    lo_send(grid_addr, "/sys/host", "s", "127.0.0.1");
    lo_send(grid_addr, "/sys/port", "i", local_grid_osc_port);
    lo_send(grid_addr, "/sys/prefix", "s", grid_prefix.c_str());
    lo_send(grid_addr, "/sys/info", "");
    gridConnected = true;
    std::cout << "Grid: registered with device on port " << device_port << " using prefix " << grid_prefix << std::endl;
}

int scaleIndexToMidiNote(int scaleIndex) {
    scaleIndex = std::max(0, std::min(15, scaleIndex));
    return minorScale[scaleIndex];
}

std::string midiNoteToName(int midiNote) {
    const char* noteNames[] = {"C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"};
    int octave = (midiNote / 12) - 1;
    int noteIndex = midiNote % 12;
    return std::string(noteNames[noteIndex]) + std::to_string(octave);
}

void initializeEnginePatterns() {
    for (int engine = 0; engine < MAX_ENGINES; engine++) {
        enginePatterns[engine].resize(16);
        for (int step = 0; step < 16; step++) {
            enginePatterns[engine][step].active = false;
            enginePatterns[engine][step].note = 60;
            enginePatterns[engine][step].velocity = 0.6f;
            activeNotes[engine][step] = -1;
        }
        
        // Initialize default parameters
        // Tighter defaults to avoid long sustains across engines
        engineParameters[engine][static_cast<int>(ParameterID::ATTACK)]  = 0.10f;
        engineParameters[engine][static_cast<int>(ParameterID::DECAY)]   = 0.10f;
        engineParameters[engine][static_cast<int>(ParameterID::SUSTAIN)] = 0.10f;
        engineParameters[engine][static_cast<int>(ParameterID::RELEASE)] = 0.10f;
        engineParameters[engine][static_cast<int>(ParameterID::FILTER_CUTOFF)] = 0.8f;
        engineParameters[engine][static_cast<int>(ParameterID::FILTER_RESONANCE)] = 0.2f;
        engineParameters[engine][static_cast<int>(ParameterID::VOLUME)] = 0.8f;
        engineParameters[engine][static_cast<int>(ParameterID::PAN)] = 0.5f;
        engineParameters[engine][static_cast<int>(ParameterID::REVERB_MIX)] = 0.3f;
    }
    // Initialize preview suppression to -1 (none)
    for (int p = 0; p < 16; ++p) drumPreviewStep[p] = -1;
    for (int e = 0; e < MAX_ENGINES; ++e) melodicPreviewStep[e] = -1;
    for (int p = 0; p < 16; ++p) padIsDown[p] = false;
}

// Convert bank + slot to absolute pattern index
int getAbsolutePatternIndex(int bank, int slot) {
    return bank * 16 + slot;
}

// Get current absolute pattern index
int getCurrentAbsolutePatternIndex() {
    return getAbsolutePatternIndex(currentPatternBank.load(), currentPatternSlot.load());
}

// Initialize pattern bank with empty patterns
void initializePatternBank() {
    for (int pattern = 0; pattern < 64; pattern++) {
        for (int engine = 0; engine < MAX_ENGINES; engine++) {
            patternBank[pattern][engine].resize(16);
            for (int step = 0; step < 16; step++) {
                patternBank[pattern][engine][step].active = false;
                patternBank[pattern][engine][step].note = 60;
                patternBank[pattern][engine][step].velocity = 0.6f;
            }
        }
    }
}

// Save current pattern to pattern bank
void saveCurrentPatternToBank(int patternSlot) {
    int absoluteIndex = getAbsolutePatternIndex(currentPatternBank.load(), patternSlot);
    if (absoluteIndex < 0 || absoluteIndex >= 64) return;

    for (int engine = 0; engine < MAX_ENGINES; engine++) {
        patternBank[absoluteIndex][engine] = enginePatterns[engine];
    }
    std::cout << "🔒 Saved current pattern to Bank " << (currentPatternBank.load() + 1) << ", Slot " << (patternSlot + 1) << " (Pattern " << (absoluteIndex + 1) << ")" << std::endl;
}

// Load pattern from bank to current pattern
void loadPatternFromBank(int patternSlot) {
    int absoluteIndex = getAbsolutePatternIndex(currentPatternBank.load(), patternSlot);
    if (absoluteIndex < 0 || absoluteIndex >= 64) return;

    for (int engine = 0; engine < MAX_ENGINES; engine++) {
        enginePatterns[engine] = patternBank[absoluteIndex][engine];
    }
    currentPatternSlot = patternSlot;
    std::cout << "📂 Loaded pattern " << (absoluteIndex + 1) << " (Bank " << (currentPatternBank.load() + 1) << ", Slot " << (patternSlot + 1) << ")" << std::endl;
}

// Clone current pattern to next available slot
void cloneCurrentPattern() {
    // Find next available pattern slot in current bank
    int targetSlot = -1;
    for (int i = 0; i < 16; i++) {
        if (i != currentPatternSlot.load()) {
            int absoluteIndex = getAbsolutePatternIndex(currentPatternBank.load(), i);
            // Check if pattern slot is empty (all steps inactive)
            bool isEmpty = true;
            for (int engine = 0; engine < MAX_ENGINES && isEmpty; engine++) {
                for (size_t step = 0; step < patternBank[absoluteIndex][engine].size() && isEmpty; step++) {
                    if (patternBank[absoluteIndex][engine][step].active) {
                        isEmpty = false;
                    }
                }
            }
            if (isEmpty) {
                targetSlot = i;
                break;
            }
        }
    }

    if (targetSlot == -1) {
        std::cout << "❌ No available pattern slots for cloning in current bank" << std::endl;
        return;
    }

    // Save current pattern first
    saveCurrentPatternToBank(currentPatternSlot.load());

    // Clone current pattern to target slot
    int targetAbsoluteIndex = getAbsolutePatternIndex(currentPatternBank.load(), targetSlot);
    for (int engine = 0; engine < MAX_ENGINES; engine++) {
        patternBank[targetAbsoluteIndex][engine] = enginePatterns[engine];
    }

    int sourceAbsolute = getCurrentAbsolutePatternIndex();
    std::cout << "📋 Cloned pattern " << (sourceAbsolute + 1) << " to pattern " << (targetAbsoluteIndex + 1) << " (Bank " << (currentPatternBank.load() + 1) << ", Slot " << (targetSlot + 1) << ")" << std::endl;
}

// OSC handlers
int grid_key_handler(const char *path, const char *types, lo_arg **argv, int argc, lo_message msg, void *user_data) {
    static bool firstMessage = true;
    if (firstMessage) {
        std::cout << "Grid: Received first OSC message from grid device: " << path << std::endl;
        firstMessage = false;
    }

    // Layout: top row y=0 function keys; 4x4 pad at x=0..3, y=1..4
    static const int PAD_ORIGIN_X = 0;
    static const int PAD_ORIGIN_Y = 1;
    static const int PAD_W = 4;
    static const int PAD_H = 4;
    static bool liveHeldInit = false;
    if (!liveHeldInit) { for (int i=0;i<PAD_W*PAD_H;i++) liveHeldNoteByPad[i] = -1; liveHeldInit = true; }

    auto padIndexFromXY = [&](int x, int y) -> int {
        if (x < PAD_ORIGIN_X || x >= PAD_ORIGIN_X + PAD_W) return -1;
        if (y < PAD_ORIGIN_Y || y >= PAD_ORIGIN_Y + PAD_H) return -1;
        int px = x - PAD_ORIGIN_X;
        int py = y - PAD_ORIGIN_Y;
        return py * PAD_W + px; // 0..15
    };

    auto noteFromPadIndex = [&](int idx) -> int {
        if (idx < 0) return 60;
        int scaleIndex = std::max(0, std::min((int)minorScale.size()-1, idx));
        float baseNote = static_cast<float>(minorScale[scaleIndex]);
        // Apply pitch adjustments (only for melodic engines, not drums)
        if (!isCurrentEngineDrum()) {
            baseNote += octaveOffset.load() * 12.0f;  // Discrete octave offset
            baseNote += pitchOffset.load();           // Continuous pitch offset
        }
        return std::max(0, std::min(127, static_cast<int>(std::round(baseNote))));  // Clamp to MIDI range
    };

    auto stepIndexFromPad = [&](int padIdx) -> int {
        return padIdx + (currentPage.load() * 16);  // Convert pad index to actual step index based on current page
    };

    auto ensurePatternSize = [&](int engine, int stepIndex) {
        if (stepIndex >= static_cast<int>(enginePatterns[engine].size())) {
            enginePatterns[engine].resize(stepIndex + 1);
        }
    };

    // Handle /monome/grid/key messages
    if (std::string(path).find("/grid/key") != std::string::npos && argc >= 3) {
        int x = argv[0]->i;
        int y = argv[1]->i;
        int state = argv[2]->i;

        // Function row (y==0)
        if (y == 0) {
            if (state == 1) { // on press actions
                if (x == 0) {
                    // SHIFT button - set shift state
                    shiftHeld = true;
                    std::cout << "SHIFT: ON" << std::endl;
                } else if (x == 1) {
                    // ENGINE select button - moved from (2,0) per grid spec
                    engineHold = true;
                } else if (x == 2) {
                    // PATTERN select - hold to select patterns 1-16 using 4x4 grid
                    patternHold = true;
                    std::cout << "🎵 PATTERN select mode - hold and press 4x4 to select patterns 1-16" << std::endl;
                } else if (x == 3) {
                    // FX button - PO-33 KO style punch-in effects
                    fxModeActive = true;
                    std::cout << "🎵 Performance FX Mode ACTIVATED" << std::endl;
                } else if (x == 4) {
                    // PLAY/PAUSE button - remapped from (0,0) to (4,0)
                    reqTogglePlay = true;
                } else if (x == 7) {
                    // COPY button - single press = copy mode, long press = clone pattern
                    copyPressTime = std::chrono::steady_clock::now();
                    copyMode = true;
                    std::cout << "📋 COPY mode ON - press step to copy, hold for pattern clone" << std::endl;
                }
            } else if (state == 0) {
                if (x == 0) {
                    // SHIFT button release - clear shift state
                    shiftHeld = false;
                    std::cout << "SHIFT: OFF" << std::endl;
                } else if (x == 1) engineHold = false; // release engine hold (moved to x=1)
                else if (x == 2) {
                    // PATTERN button release - exit pattern selection mode and chaining mode
                    patternHold = false;
                    if (chainingMode.load()) {
                        chainingMode = false;
                    }
                }
                else if (x == 3) {
                    // FX button release - deactivate effects
                    fxModeActive = false;
                    // Deactivate effects globally
                    if (performanceFX.isEffectActive(PerformanceFX::RETRIGGER_PATTERN) || performanceFX.isEffectActive(PerformanceFX::REVERSE)) {
                        // Restore original pattern
                        for (int row = 0; row < MAX_ENGINES; ++row) {
                            for (int step = 0; step < 16; ++step) {
                                enginePatterns[row][step] = performanceFX.originalPattern[row][step];
                            }
                        }
                    }
                    performanceFX.clearAllEffects();
                    std::cout << "🎵 Performance FX Mode DEACTIVATED" << std::endl;
                } else if (x == 4) muteHold = false;    // release mute view
                else if (x == 7) {
                    // COPY button release - check for long press (pattern clone)
                    auto now = std::chrono::steady_clock::now();
                    auto holdDuration = std::chrono::duration_cast<std::chrono::milliseconds>(now - copyPressTime).count();

                    if (holdDuration > 500) {  // Long press = clone pattern
                        cloneCurrentPattern();
                    } else {
                        // Short press = toggle copy mode
                        copyMode = !copyMode.load();
                        std::cout << (copyMode ? "📋 COPY mode ON" : "📋 COPY mode OFF") << std::endl;
                    }
                }
            }
            return 0;
        }

        // Inside 4x4 pad region
        int padIdx = padIndexFromXY(x, y);
        // MUTE/SOLO button: x=4,y=1 - remapped from original (4,0)
        if (x == 4 && y == 1) {
            if (state == 1) {
                auto now = std::chrono::steady_clock::now();
                if (lastMutePress.time_since_epoch().count() != 0) {
                    auto dt = std::chrono::duration_cast<std::chrono::milliseconds>(now - lastMutePress).count();
                    if (dt < 300) {
                        if (soloEngine == currentEngineRow) {
                            soloEngine = -1;
                            std::cout << "Solo OFF" << std::endl;
                        } else {
                            soloEngine = currentEngineRow;
                            std::cout << "Solo engine " << currentEngineRow << std::endl;
                        }
                    }
                }
                lastMutePress = now;
                muteHold = true;
            } else if (state == 0) {
                muteHold = false;
            }
            return 0;
        }

        // DELETE button: x=4,y=3 - button above Write
        // When not playing: enables DELETE mode where 4x4 presses delete notes
        if (x == 4 && y == 3) {
            if (state == 1) { // press
                if (!playing) {
                    // Toggle DELETE mode (only works when not playing)
                    deleteMode = !deleteMode.load();
                    std::cout << (deleteMode ? "DELETE mode ON - press 4x4 to delete steps, long press to clear all" : "DELETE mode OFF") << std::endl;
                } else {
                    std::cout << "DELETE mode only available when not playing" << std::endl;
                }
            }
            return 0;
        }

        // WRITE button: x=4,y=4 - remapped from original (1,0)
        // Advanced behavior: toggle when not playing, hold when playing
        // PATTERN + WRITE: enter/exit chaining mode
        if (x == 4 && y == 4) {
            if (state == 1) { // press
                // Check for PATTERN + WRITE combination
                if (patternHold.load()) {
                    // PATTERN + WRITE: toggle chaining mode
                    chainingMode = !chainingMode.load();
                    if (chainingMode) {
                        patternChain.clear();  // Start fresh chain
                    }
                    return 0;
                }

                if (!playing) {
                    // When not playing: toggle write mode
                    writeMode = !writeMode.load();
                    std::cout << (writeMode ? "Write mode ON" : "Write mode OFF") << std::endl;
                } else {
                    // When playing: enable write mode while held
                    writeMode = true;
                    std::cout << "Write mode ON (hold)" << std::endl;
                }
            } else if (state == 0) { // release
                if (playing) {
                    // When playing: disable write mode on release
                    writeMode = false;
                    std::cout << "Write mode OFF (released)" << std::endl;
                }
                // When not playing: do nothing on release (toggle handled on press)
            }
            return 0;
        }

        if (padIdx >= 0) {
            // Handle pattern selection when PATTERN hold is active
            if (patternHold.load() && state == 1) {
                // Check if in chaining mode
                if (chainingMode.load()) {
                    // Add pattern to chain
                    int absolutePattern = getAbsolutePatternIndex(currentPatternBank.load(), padIdx);
                    patternChain.push_back(absolutePattern);
                    std::cout << "🔗 Added pattern " << (absolutePattern + 1) << " to chain. Chain: ";
                    for (size_t i = 0; i < patternChain.size(); i++) {
                        if (i > 0) std::cout << " → ";
                        std::cout << (patternChain[i] + 1);
                    }
                    std::cout << std::endl;
                    return 0;
                }

                // Normal pattern selection (not chaining)
                // Save current pattern before switching
                saveCurrentPatternToBank(currentPatternSlot.load());

                // Switch to selected pattern (padIdx 0-15 = patterns 1-16)
                loadPatternFromBank(padIdx);
                std::cout << "📋 Switched to pattern " << (padIdx + 1) << std::endl;
                return 0;
            }

            // Handle FX selection when FX mode is active
            if (fxModeActive && state == 1) {
                PerformanceFX effect = static_cast<PerformanceFX>(padIdx);

                // Check if write mode is active - if so, bake the FX into the pattern
                if (writeMode.load()) {
                    bakePerformanceFXIntoPattern(effect);
                    std::cout << "🔥 Performance FX: " << PERFORMANCE_FX_NAMES[padIdx] << " BAKED INTO PATTERN!" << std::endl;
                    return 0;
                }

                // Normal FX mode: Toggle effect for stacking - add if not active, remove if active
                if (performanceFX.isEffectActive(effect)) {
                    performanceFX.deactivateEffect(effect);
                    std::cout << "🎵 Performance FX: " << PERFORMANCE_FX_NAMES[padIdx] << " DEACTIVATED" << std::endl;
                } else {
                    performanceFX.activateEffect(effect, 1.0f);

                    // Initialize effect-specific state when first adding
                    switch (effect) {
                        case PerformanceFX::LOOP_16:
                            performanceFX.loopLength = 4;  // 16th note loop
                            break;
                        case PerformanceFX::LOOP_12:
                            performanceFX.loopLength = 3;  // 12th note loop
                            break;
                        case PerformanceFX::LOOP_SHORT:
                            performanceFX.loopLength = 2;  // 32nd note segments
                            break;
                        case PerformanceFX::LOOP_SHORTER:
                            performanceFX.loopLength = 1;  // 48th note segments
                            break;
                        case PerformanceFX::RETRIGGER_PATTERN:
                            // Backup current pattern and shuffle step order (only once)
                            if (performanceFX.activeEffects.size() == 1) { // First effect being added
                                for (int row = 0; row < MAX_ENGINES; ++row) {
                                    for (int step = 0; step < 16; ++step) {
                                        performanceFX.originalPattern[row][step] = enginePatterns[row][step];
                                    }
                                }
                            }
                            // Initialize shuffled order
                            for (int i = 0; i < 16; ++i) {
                                performanceFX.shuffledStepOrder[i] = i;
                            }
                            // Simple shuffle
                            for (int i = 15; i > 0; --i) {
                                int j = rand() % (i + 1);
                                std::swap(performanceFX.shuffledStepOrder[i], performanceFX.shuffledStepOrder[j]);
                            }
                            break;
                        case PerformanceFX::REVERSE:
                            // Backup original pattern (only once)
                            if (performanceFX.activeEffects.size() == 1) { // First effect being added
                                for (int row = 0; row < MAX_ENGINES; ++row) {
                                    for (int step = 0; step < 16; ++step) {
                                        performanceFX.originalPattern[row][step] = enginePatterns[row][step];
                                    }
                                }
                            }
                            break;
                        default:
                            break;
                    }

                    std::cout << "🎵 Performance FX: " << PERFORMANCE_FX_NAMES[padIdx] << " ACTIVATED (Stacked: "
                              << performanceFX.activeEffects.size() << ")" << std::endl;
                }
                return 0;
            } else if (fxModeActive && state == 0) {
                // Release 4x4 button while FX held - DEACTIVATE that specific effect
                PerformanceFX effect = static_cast<PerformanceFX>(padIdx);
                if (performanceFX.isEffectActive(effect)) {
                    performanceFX.deactivateEffect(effect);
                    std::cout << "🎵 Performance FX: " << PERFORMANCE_FX_NAMES[padIdx] << " RELEASED (Remaining: "
                              << performanceFX.activeEffects.size() << ")" << std::endl;
                }
                return 0;
            }

            // Handle DELETE mode when active
            if (deleteMode && state == 1) {
                int engine = currentEngineRow;
                int stepIndex = stepIndexFromPad(padIdx);

                if (isCurrentEngineDrum()) {
                    // For drum engines: clear the specific drum pad's pattern
                    drumMasks[padIdx] = 0;  // Clear all steps for this drum pad
                    std::cout << "DELETED all steps for drum pad " << (padIdx + 1) << std::endl;
                } else {
                    // For melodic engines: clear the specific step
                    if (stepIndex < static_cast<int>(enginePatterns[engine].size())) {
                        enginePatterns[engine][stepIndex].active = false;
                        std::cout << "DELETED step " << (stepIndex + 1) << " (page " << (currentPage.load() + 1) << ")" << std::endl;
                    }
                }
                return 0;
            }

            // Debounce: ignore repeat press events while held
            if (state == 1) {
                bool wasDown = padIsDown[padIdx].exchange(true);
                if (wasDown) return 0;
            } else if (state == 0) {
                padIsDown[padIdx] = false;
            }

            // SHIFT + pad behavior: LFO assignment for pads 0-7 (pad #1-8)
            if (shiftHeld && state == 1 && padIdx < 8) {
                int lfoIndex = padIdx; // pad 0 = LFO 0, pad 1 = LFO 1, etc. (0-7)
                int lfoNumber = lfoIndex + 1; // for display: LFO #1-8

                if (selectedParamIndex < (int)extendedVisibleParams.size()) {
                    int pid = getExtendedParameterId(selectedParamIndex);
                    if (pid != -1) {
                        // Handle pseudo-parameters separately
                        if (pid == PSEUDO_PARAM_OCTAVE || pid == PSEUDO_PARAM_PITCH) {
                            // Toggle LFO assignment for pseudo-parameters
                            if (pseudoParamLFOs[pid].active && pseudoParamLFOs[pid].lfoIndex == lfoIndex) {
                                // Remove assignment
                                pseudoParamLFOs[pid].active = false;
                                pseudoParamLFOs[pid].lfoIndex = -1;
                                std::cout << "LFO #" << lfoNumber << " removed from pseudo-param "
                                          << (pid == PSEUDO_PARAM_OCTAVE ? "octave" : "pitch") << std::endl;
                            } else {
                                // Add assignment
                                pseudoParamLFOs[pid].active = true;
                                pseudoParamLFOs[pid].lfoIndex = lfoIndex;
                                pseudoParamLFOs[pid].depth = 0.5f;
                                std::cout << "LFO #" << lfoNumber << " assigned to pseudo-param "
                                          << (pid == PSEUDO_PARAM_OCTAVE ? "octave" : "pitch") << std::endl;
                            }
                            return 0;
                        }

                        // Handle real parameters

                    int slot = rowToSlot[currentEngineRow];
                    if (slot < 0) slot = 0;

                    // Check if LFO is already assigned to this parameter
                    int activeMask = 0;
                    float currentValue = 0.0f;
                    ether_get_parameter_lfo_info(etherEngine, slot, pid, &activeMask, &currentValue);

                    bool isAssigned = (activeMask & (1 << lfoIndex)) != 0;
                    std::string paramName = parameterNames[pid];

                    if (isAssigned) {
                        // Unassign: Remove LFO from parameter
                        ether_remove_lfo_assignment_by_param(etherEngine, slot, lfoIndex, pid);
                        std::cout << "SHIFT+PAD: Removed LFO #" << lfoNumber << " from parameter '" << paramName << "'" << std::endl;
                    } else {
                        // Assign: Add LFO to parameter
                        extern float lfoDepth[8];
                        float depth = lfoDepth[lfoIndex];
                        ether_assign_lfo_to_param_id(etherEngine, slot, lfoIndex, pid, depth);
                        std::cout << "SHIFT+PAD: Assigned LFO #" << lfoNumber << " to parameter '"
                                  << paramName << "' (depth: " << std::fixed << std::setprecision(2) << depth << ")" << std::endl;
                    }

                        // Force refresh of LFO assignment display if it's open
                        extern bool showLFOAssign;
                        extern uint32_t lfoAssignMask;
                        if (showLFOAssign) {
                            // Update the display mask
                            ether_get_parameter_lfo_info(etherEngine, slot, pid, &activeMask, &currentValue);
                            lfoAssignMask = static_cast<uint32_t>(activeMask);
                        }
                    }
                } else {
                    std::cout << "SHIFT+PAD: No parameter selected for LFO #" << lfoNumber << " assignment" << std::endl;
                }
                return 0;
            }

            // SHIFT + pad behavior: Additional mode controls for pads 8-15 (pad #9-16)
            if (shiftHeld && state == 1 && padIdx >= 8) {
                if (padIdx == 8) {  // Pad #9 - Pattern Gate mode
                    patternGateSettings.enabled = !patternGateSettings.enabled;
                    std::cout << "SHIFT+PAD: Pattern Gate " << (patternGateSettings.enabled ? "ON" : "OFF") << std::endl;
                    return 0;
                } else if (padIdx == 9) {  // Pad #10 - Arpeggiator mode
                    arpeggiatorMode = !arpeggiatorMode.load();
                    return 0;
                } else if (padIdx == 10) {  // Pad #11 - Retrigger mode
                    retriggerMode = !retriggerMode.load();
                    return 0;
                } else if (padIdx == 11) {  // Pad #12 - Increase octave
                    if (!isCurrentEngineDrum()) {
                        octaveOffset = std::min(4, octaveOffset.load() + 1);
                        std::cout << "SHIFT+PAD: Octave +" << octaveOffset.load() << std::endl;
                    }
                    return 0;
                } else if (padIdx == 12) {  // Pad #13 - Pagination left
                    if (currentPage > 0) {
                        currentPage--;
                        std::cout << "SHIFT+PAD: Pattern page " << (currentPage + 1) << "/4 (steps: " << ((currentPage + 1) * 16) << ")" << std::endl;
                    } else {
                        std::cout << "SHIFT+PAD: Already on first page" << std::endl;
                    }
                    return 0;
                } else if (padIdx == 13) {  // Pad #14 - Pagination right
                    if (currentPage < 3) {
                        currentPage++;
                        std::cout << "SHIFT+PAD: Pattern page " << (currentPage + 1) << "/4 (steps: " << ((currentPage + 1) * 16) << ")" << std::endl;
                    } else {
                        std::cout << "SHIFT+PAD: Already on last page" << std::endl;
                    }
                    return 0;
                } else if (padIdx == 14) {  // Pad #15 - Accent mode
                    accentMode = !accentMode.load();
                    std::cout << "SHIFT+PAD: Accent mode " << (accentMode ? "ON" : "OFF") << std::endl;
                    return 0;
                } else if (padIdx == 15) {  // Pad #16 - Decrease octave
                    if (!isCurrentEngineDrum()) {
                        octaveOffset = std::max(-4, octaveOffset.load() - 1);
                        std::cout << "SHIFT+PAD: Octave " << octaveOffset.load() << std::endl;
                    }
                    return 0;
                }
            }

            // PO-style live write: when playing and write is ON, pad presses place hits at current step
            if (playing && writeMode && state == 1) {
                if (isCurrentEngineDrum()) {
                    drumMasks[padIdx] |= (1u << currentStep);
                    drumPreviewStep[padIdx] = currentStep.load();
                    int slot = rowToSlot[currentEngineRow]; if (slot < 0) slot = 0;
                    ether_set_active_instrument(etherEngine, slot);
                    float vel = accentLatch ? 1.0f : 0.9f;
                    ether_note_on(etherEngine, DRUM_PAD_NOTES[padIdx], vel, 0.0f);
                    ether_trigger_instrument_lfos(etherEngine, slot);
                    return 0;
                } else {
                    int engine = currentEngineRow;
                    int liveNote = noteFromPadIndex(padIdx);
                    lastLiveNote = liveNote;
                    enginePatterns[engine][currentStep].active = true;
                    enginePatterns[engine][currentStep].note = liveNote;
                    melodicPreviewStep[engine] = currentStep.load();
                    int slot = rowToSlot[currentEngineRow]; if (slot < 0) slot = 0;
                    ether_set_active_instrument(etherEngine, slot);
                    float vel = accentLatch ? 1.0f : 0.8f;
                    ether_note_on(etherEngine, liveNote, vel, 0.0f);
                    ether_trigger_instrument_lfos(etherEngine, slot);
                    return 0;
                }
            }
            if (muteHold) {
                if (state == 1) {
                    int eng = std::min(MAX_ENGINES - 1, padIdx);
                    rowMuted[eng] = !rowMuted[eng];
                    std::cout << "Row " << eng << (rowMuted[eng]?" muted":" unmuted") << std::endl;
                }
                return 0;
            }

            if (engineHold) {
                if (state == 1) {
                    int newEngine = std::min(MAX_ENGINES - 1, padIdx);
                    currentEngineRow = newEngine;
                    if (etherEngine) {
                        int slot = rowToSlot[newEngine]; if (slot < 0) slot = 0;
                        ether_set_active_instrument(etherEngine, slot);
                    }
                    const char* techName = ether_get_engine_type_name(newEngine);
                    const char* name = getDisplayName(techName);
                    std::cout << "Engine -> " << newEngine << ": " << (name ? name : "Unknown") << std::endl;
                }
                return 0;
            }

            // Drum engine behavior
            if (isCurrentEngineDrum()) {
                if (writeMode) {
                    if (state == 1) {
                        int stepIdx = padIdx;
                        drumMasks[selectedDrumPad] ^= (1u << stepIdx);
                    }
                    return 0;
                }
                else {
                    int note = DRUM_PAD_NOTES[padIdx];
                    if (state == 1) {
                        selectedDrumPad = padIdx; // arm this drum
                        // Jump the terminal menu to the drum pad editor row
                        selectedParamIndex = (int)uiParams.size()+1;
                        int slot = rowToSlot[currentEngineRow]; if (slot < 0) slot = 0;
                        ether_set_active_instrument(etherEngine, slot);
                        float vel = accentLatch ? 1.0f : 0.9f;
                        ether_note_on(etherEngine, note, vel, 0.0f);
                    } else if (state == 0) {
                        int slot = rowToSlot[currentEngineRow]; if (slot < 0) slot = 0;
                        ether_set_active_instrument(etherEngine, slot);
                        ether_note_off(etherEngine, note);
                    }
                    return 0;
                }
            }

            // Melodic live play
            {
                int liveNote = noteFromPadIndex(padIdx);
                if (writeMode && state == 1) {
                    // Toggle step and bake lastLiveNote if available
                    int engine = currentEngineRow;
                    int stepIndex = stepIndexFromPad(padIdx);
                    ensurePatternSize(engine, stepIndex);

                    enginePatterns[engine][stepIndex].active = !enginePatterns[engine][stepIndex].active;
                    if (lastLiveNote >= 0) {
                        enginePatterns[engine][stepIndex].note = lastLiveNote;
                    } else {
                        enginePatterns[engine][stepIndex].note = liveNote;
                    }

                    // Apply mode effects when writing steps (mutually exclusive)
                    if (enginePatterns[engine][stepIndex].active) {
                        enginePatterns[engine][stepIndex].hasAccent = accentMode.load();

                        // Effects are mutually exclusive - only one can be active
                        if (retriggerMode.load()) {
                            enginePatterns[engine][stepIndex].hasRetrigger = true;
                            enginePatterns[engine][stepIndex].hasArpeggiator = false;
                        } else if (arpeggiatorMode.load()) {
                            enginePatterns[engine][stepIndex].hasArpeggiator = true;
                            enginePatterns[engine][stepIndex].hasRetrigger = false;
                        } else {
                            enginePatterns[engine][stepIndex].hasRetrigger = false;
                            enginePatterns[engine][stepIndex].hasArpeggiator = false;
                        }
                    }

                    std::cout << "Step " << (stepIndex+1) << " (page " << (currentPage.load()+1) << ")" << (enginePatterns[engine][stepIndex].active?" ON":" OFF");
                    if (enginePatterns[engine][stepIndex].active) {
                        if (enginePatterns[engine][stepIndex].hasAccent) std::cout << " [ACCENT]";
                        if (enginePatterns[engine][stepIndex].hasRetrigger) std::cout << " [RETRIGGER]";
                    }
                    std::cout << std::endl;
                    return 0;
                }
                if (state == 1) {
                    lastLiveNote = liveNote;
                    int slot = rowToSlot[currentEngineRow]; if (slot < 0) slot = 0;
                    ether_set_active_instrument(etherEngine, slot);
                    float vel = accentLatch ? 1.0f : 0.8f;
                    ether_note_on(etherEngine, liveNote, vel, 0.0f);
                    ether_trigger_instrument_lfos(etherEngine, slot);
                    liveHeldNoteByPad[padIdx] = liveNote;
                    return 0;
                } else if (state == 0) {
                    int held = liveHeldNoteByPad[padIdx];
                    if (held >= 0) {
                        int slot = rowToSlot[currentEngineRow]; if (slot < 0) slot = 0;
                        ether_set_active_instrument(etherEngine, slot);
                        ether_note_off(etherEngine, held);
                        liveHeldNoteByPad[padIdx] = -1;
                    }
                    return 0;
                }
            }

            if (writeMode) {
                if (state == 1) {
                    // Toggle step and bake lastLiveNote if available
                    int engine = currentEngineRow;
                    int stepIndex = stepIndexFromPad(padIdx);
                    ensurePatternSize(engine, stepIndex);

                    enginePatterns[engine][stepIndex].active = !enginePatterns[engine][stepIndex].active;
                    if (lastLiveNote >= 0) {
                        enginePatterns[engine][stepIndex].note = lastLiveNote;
                    }

                    // Apply mode effects when writing steps (mutually exclusive)
                    if (enginePatterns[engine][stepIndex].active) {
                        enginePatterns[engine][stepIndex].hasAccent = accentMode.load();

                        // Effects are mutually exclusive - only one can be active
                        if (retriggerMode.load()) {
                            enginePatterns[engine][stepIndex].hasRetrigger = true;
                            enginePatterns[engine][stepIndex].hasArpeggiator = false;
                        } else if (arpeggiatorMode.load()) {
                            enginePatterns[engine][stepIndex].hasArpeggiator = true;
                            enginePatterns[engine][stepIndex].hasRetrigger = false;
                        } else {
                            enginePatterns[engine][stepIndex].hasRetrigger = false;
                            enginePatterns[engine][stepIndex].hasArpeggiator = false;
                        }
                    }

                    std::cout << "Step " << (stepIndex+1) << " (page " << (currentPage.load()+1) << ")" << (enginePatterns[engine][stepIndex].active?" ON":" OFF");
                    if (enginePatterns[engine][stepIndex].active) {
                        std::cout << " note=" << enginePatterns[engine][stepIndex].note;
                        if (enginePatterns[engine][stepIndex].hasAccent) std::cout << " [ACCENT]";
                        if (enginePatterns[engine][stepIndex].hasRetrigger) std::cout << " [RETRIGGER]";
                    }
                    std::cout << std::endl;
                }
                return 0;
            }

            // Notes mode (live play)
            int note = noteFromPadIndex(padIdx);
            if (state == 1) {
                lastLiveNote = note;
                int slot = rowToSlot[currentEngineRow]; if (slot < 0) slot = 0;
                ether_set_active_instrument(etherEngine, slot);
                ether_note_on(etherEngine, note, 0.8f, 0.0f);
                ether_trigger_instrument_lfos(etherEngine, slot);
                liveHeldNoteByPad[padIdx] = note;
            } else if (state == 0) {
                int held = liveHeldNoteByPad[padIdx];
                if (held >= 0) {
                    int slot = rowToSlot[currentEngineRow]; if (slot < 0) slot = 0;
                    ether_set_active_instrument(etherEngine, slot);
                    ether_note_off(etherEngine, held);
                    liveHeldNoteByPad[padIdx] = -1;
                }
            }
            return 0;
        }
    }
    return 0;
}

// Handle serialosc device announcements: /serialosc/device ssi (id, type, port)
int serialosc_device_handler(const char *path, const char *types, lo_arg **argv, int argc, lo_message /*msg*/, void * /*user_data*/) {
    std::cout << "serialosc: " << path << " types=" << (types ? types : "") << " argc=" << argc << std::endl;
    if (argc >= 3 && types && std::string(types).rfind("ssi", 0) == 0) {
        const char* id = &argv[0]->s;
        const char* type = &argv[1]->s;
        int port = argv[2]->i;
        std::cout << "serialosc device: id=" << (id ? id : "?") << " type=" << (type ? type : "?") << " port=" << port << std::endl;
        register_grid_with_device(port);
    } else if (argc >= 3) {
        int port = argv[2]->i;
        std::cout << "serialosc device: (untyped) port=" << port << std::endl;
        register_grid_with_device(port);
    }
    return 0;
}

void updateGridLEDs() {
    if (!gridConnected || !grid_addr) return;

    // Clear all LEDs first
    lo_send(grid_addr, (grid_prefix + "/grid/led/all").c_str(), "i", 0);

    static const int PAD_ORIGIN_X = 0;
    static const int PAD_ORIGIN_Y = 1;
    static const int PAD_W = 4;
    static const int PAD_H = 4;

    // Pattern hold view: show 4x4 pattern slots
    if (patternHold.load()) {
        for (int i = 0; i < PAD_W * PAD_H; i++) {
            int x = PAD_ORIGIN_X + (i % PAD_W);
            int y = PAD_ORIGIN_Y + (i / PAD_W);
            int brightness = 0;

            if (chainingMode.load()) {
                // Chaining mode: show patterns in chain as bright, current pattern as medium, others dim
                int absolutePattern = getAbsolutePatternIndex(currentPatternBank.load(), i);
                bool inChain = false;
                for (int chainPattern : patternChain) {
                    if (chainPattern == absolutePattern) {
                        inChain = true;
                        break;
                    }
                }

                if (inChain) {
                    brightness = 15;  // Patterns in chain bright
                } else if (i == currentPatternSlot.load()) {
                    brightness = 8;   // Current pattern medium
                } else {
                    brightness = 2;   // Available pattern slots very dim
                }
            } else {
                // Normal pattern selection mode
                if (i == currentPatternSlot.load()) {
                    brightness = 15;  // Current pattern bright
                } else {
                    brightness = 4;   // Available pattern slots dim
                }
            }

            if (brightness > 0) {
                lo_send(grid_addr, (grid_prefix + "/grid/led/level/set").c_str(), "iii", x, y, brightness);
            }
        }

        // PATTERN button indicator - blink when in chaining mode
        int patternButtonBrightness = chainingMode.load() ? (((int)(time(nullptr) * 4) % 2) ? 15 : 8) : 15;
        lo_send(grid_addr, (grid_prefix + "/grid/led/level/set").c_str(), "iii", 2, 0, patternButtonBrightness);
        return;
    }

    // Mute hold view: show 4x4 engine mute states
    if (muteHold) {
        for (int i = 0; i < PAD_W * PAD_H; i++) {
            int x = PAD_ORIGIN_X + (i % PAD_W);
            int y = PAD_ORIGIN_Y + (i / PAD_W);
            int brightness = 0;
            int eng = i;
            if (eng < MAX_ENGINES) {
                if (soloEngine >= 0) {
                    brightness = (eng == soloEngine) ? 15 : 2;
                } else {
                    brightness = rowMuted[eng] ? 2 : 12;
                }
            }
            if (brightness > 0) {
                lo_send(grid_addr, (grid_prefix + "/grid/led/level/set").c_str(), "iii", x, y, brightness);
            }
        }
        // Function row indicators
        lo_send(grid_addr, (grid_prefix + "/grid/led/level/set").c_str(), "iii", 4, 0, 15);
        return;
    }


    // MUTE/SOLO button indicator: x=4,y=1 - remapped from original (4,0)
    {
        int mx = 4, my = 1;
        int b = muteHold ? 15 : 4;
        lo_send(grid_addr, (grid_prefix + "/grid/led/level/set").c_str(), "iii", mx, my, b);
    }

    // Function row indicators
    // SHIFT button at (0,0) - advanced grid controller
    lo_send(grid_addr, (grid_prefix + "/grid/led/level/set").c_str(), "iii", 0, 0, shiftHeld ? 15 : 4);
    // ENGINE select at (1,0) - moved from (2,0) per grid spec
    lo_send(grid_addr, (grid_prefix + "/grid/led/level/set").c_str(), "iii", 1, 0, engineHold ? 15 : 4);
    // PATTERN select at (2,0) - placeholder for future implementation
    lo_send(grid_addr, (grid_prefix + "/grid/led/level/set").c_str(), "iii", 2, 0, 4);
    // Clear at (3,0)
    lo_send(grid_addr, (grid_prefix + "/grid/led/level/set").c_str(), "iii", 3, 0, 4);
    // PLAY/PAUSE button at (4,0) - remapped from (0,0)
    lo_send(grid_addr, (grid_prefix + "/grid/led/level/set").c_str(), "iii", 4, 0, playing ? 15 : 4);
    // COPY button at (7,0) - short press = copy mode, long press = clone pattern
    lo_send(grid_addr, (grid_prefix + "/grid/led/level/set").c_str(), "iii", 7, 0, copyMode ? 15 : 4);
    // DELETE button at (4,3) - button above Write
    lo_send(grid_addr, (grid_prefix + "/grid/led/level/set").c_str(), "iii", 4, 3, deleteMode ? 15 : 4);
    // WRITE button at (4,4) - remapped from (1,0)
    lo_send(grid_addr, (grid_prefix + "/grid/led/level/set").c_str(), "iii", 4, 4, writeMode ? 15 : 4);

    // 4x4 panel
    if (engineHold) {
        // Show engine selection across 4x4
        for (int i = 0; i < PAD_W * PAD_H; i++) {
            int x = PAD_ORIGIN_X + (i % PAD_W);
            int y = PAD_ORIGIN_Y + (i / PAD_W);
            int b = (i == currentEngineRow) ? 15 : 4;
            lo_send(grid_addr, (grid_prefix + "/grid/led/level/set").c_str(), "iii", x, y, b);
        }
        return;
    }

    if (writeMode) {
        int engine = currentEngineRow;
        for (int i = 0; i < PAD_W * PAD_H; i++) {
            int x = PAD_ORIGIN_X + (i % PAD_W);
            int y = PAD_ORIGIN_Y + (i / PAD_W);
            int b = 0;
            if (isCurrentEngineDrum()) {
                // In write mode, show selected drum's 16-step pattern across time
                bool on = (drumMasks[selectedDrumPad] >> i) & 1u;
                b = on ? 12 : ((playing && i == currentStep) ? 2 : 0);
            } else {
                // Ghost steps from other engines dim
                bool ghost = false;
                for (int e = 0; e < MAX_ENGINES; ++e) {
                    if (e == engine) continue;
                    if (enginePatterns[e][i].active) { ghost = true; break; }
                }
                if (ghost) b = 3; // dim ghost
                // Current engine step brighter
                if (enginePatterns[engine][i].active) {
                    b = (playing && i == currentStep) ? 15 : 8;
                } else if (playing && i == currentStep) {
                    b = std::max(b, 2); // ensure playhead visible
                }
            }
            if (b > 0) {
                lo_send(grid_addr, (grid_prefix + "/grid/led/level/set").c_str(), "iii", x, y, b);
            }
        }
        return;
    }

    // Notes mode: show current engine pattern brightly, others as ghost; playhead dimly
    for (int i = 0; i < PAD_W * PAD_H; i++) {
        int x = PAD_ORIGIN_X + (i % PAD_W);
        int y = PAD_ORIGIN_Y + (i / PAD_W);
        int b = 0;
        if (isCurrentEngineDrum()) {
            // Bright for steps written to selected drum pad
            bool on = ((drumMasks[selectedDrumPad] >> i) & 1u) != 0;
            if (on) b = 12;
        } else {
            // Bright for current engine's own steps
            if (enginePatterns[currentEngineRow][i].active) {
                b = 12;
            } else {
                // Dim ghost if any other engine has a step here
                bool ghost = false;
                for (int e = 0; e < MAX_ENGINES; ++e) {
                    if (e == currentEngineRow) continue;
                    if (enginePatterns[e][i].active) { ghost = true; break; }
                }
                if (ghost) b = 3;
            }
        }
        if (playing && i == currentStep) b = std::max(b, 2);
        if (b > 0) {
            lo_send(grid_addr, (grid_prefix + "/grid/led/level/set").c_str(), "iii", x, y, b);
        }
    }
}

// Global function to get next step with Performance FX applied (supports stacking)
int getNextStep(int currentStep) {
    if (!performanceFX.hasActiveEffects()) {
        return (currentStep + 1) % 16;  // Normal progression
    }

    // Debug print to confirm effects are active
    static int debugCounter = 0;
    if (debugCounter++ % 16 == 0) {  // Print every 16 steps
        std::cout << "🔥 STACKED FX ACTIVE (" << performanceFX.activeEffects.size() << "): ";
        for (auto effect : performanceFX.activeEffects) {
            std::cout << PERFORMANCE_FX_NAMES[static_cast<int>(effect)] << " ";
        }
        std::cout << std::endl;
    }

    int nextStep = currentStep;
    bool stepModified = false;

    // Apply each active effect in sequence
    // Order of application matters for stacking behavior
    for (auto effect : performanceFX.activeEffects) {
        float intensity = performanceFX.effectIntensities.at(effect);
        int tempStep = nextStep;

        switch (effect) {
            case PerformanceFX::REVERSE:
                // Play sequence backwards
                tempStep = (nextStep - 1 + 16) % 16;
                stepModified = true;
                break;

            case PerformanceFX::LOOP_16:
                // Loop every 1 step - stay on same step
                tempStep = nextStep;
                stepModified = true;
                break;

            case PerformanceFX::LOOP_12:
                // Loop every 2 steps
                tempStep = (nextStep + 1) % 2 == 0 ? nextStep - 1 : nextStep + 1;
                stepModified = true;
                break;

            case PerformanceFX::LOOP_SHORT:
                // Loop every 4 steps
                tempStep = (nextStep + 1) % 4 == 0 ? nextStep - 3 : nextStep + 1;
                stepModified = true;
                break;

            case PerformanceFX::LOOP_SHORTER:
                // Loop every 8 steps
                tempStep = (nextStep + 1) % 8 == 0 ? nextStep - 7 : nextStep + 1;
                stepModified = true;
                break;

            // Double-time loop effects - play through all steps in loop but at double BPM
            case PerformanceFX::LOOP_16_DOUBLE:
                // Double-time: Loop every 1 step but at double BPM - same step repeated rapidly
                tempStep = nextStep; // Stay on current step for continuous rapid triggering
                stepModified = true;
                break;

            case PerformanceFX::LOOP_12_DOUBLE:
                // Double-time: Loop every 2 steps at double BPM - cycle through both steps rapidly
                {
                    static int doubleTime12Counter = 0;
                    int loopStart = (nextStep / 2) * 2; // Find start of 2-step segment
                    doubleTime12Counter = (doubleTime12Counter + 1) % 2; // Cycle 0,1,0,1...
                    tempStep = loopStart + doubleTime12Counter; // Alternate between the 2 steps
                    stepModified = true;
                }
                break;

            case PerformanceFX::LOOP_SHORT_DOUBLE:
                // Double-time: Loop every 4 steps at double BPM - cycle through all 4 steps rapidly
                {
                    static int doubleTimeShortCounter = 0;
                    int loopStart = (nextStep / 4) * 4; // Find start of 4-step segment
                    doubleTimeShortCounter = (doubleTimeShortCounter + 1) % 4; // Cycle 0,1,2,3,0,1,2,3...
                    tempStep = loopStart + doubleTimeShortCounter; // Cycle through all 4 steps
                    stepModified = true;
                }
                break;

            case PerformanceFX::LOOP_SHORTER_DOUBLE:
                // Double-time: Loop every 8 steps at double BPM - cycle through all 8 steps rapidly
                {
                    static int doubleTimeShorterCounter = 0;
                    int loopStart = (nextStep / 8) * 8; // Find start of 8-step segment
                    doubleTimeShorterCounter = (doubleTimeShorterCounter + 1) % 8; // Cycle 0,1,2,3,4,5,6,7,0,1...
                    tempStep = loopStart + doubleTimeShorterCounter; // Cycle through all 8 steps
                    stepModified = true;
                }
                break;

            case PerformanceFX::SCRATCH:
                // Scratch ping-pong: bounce between 4-step segments
                {
                    static bool scratchDirection = true;
                    static int scratchSegmentStart = 0;

                    if (scratchDirection) {
                        // Forward through 4-step segment
                        tempStep = scratchSegmentStart + ((nextStep - scratchSegmentStart + 1) % 4);
                        if (tempStep == scratchSegmentStart + 3) {
                            scratchDirection = false; // Switch to reverse at end
                        }
                    } else {
                        // Reverse through 4-step segment
                        tempStep = scratchSegmentStart + ((nextStep - scratchSegmentStart + 3) % 4);
                        if (tempStep == scratchSegmentStart) {
                            scratchDirection = true; // Switch to forward at start
                            scratchSegmentStart = (scratchSegmentStart + 4) % 16; // Move to next segment
                        }
                    }
                    stepModified = true;
                }
                break;

            case PerformanceFX::STUTTER_SWEEP:
                // Volume tremolo & filter sweep effect
                performanceFX.stutterCounter++;
                if (performanceFX.stutterCounter % 8 == 0) {
                    tempStep = nextStep;  // Stutter every 8th beat
                    stepModified = true;
                }
                break;

            case PerformanceFX::TRANCE_GATE:
                // Stepped gate that chops the sound rhythmically
                static int gatePattern[] = {1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0};
                if (!gatePattern[nextStep]) {
                    // Skip this step
                    tempStep = (nextStep + 2) % 16;
                    stepModified = true;
                }
                break;

            case PerformanceFX::HALF_RATE:
                // Halves speed and pitch - skip every other step
                static bool skipNext = false;
                skipNext = !skipNext;
                if (skipNext) {
                    tempStep = nextStep;  // Stay on current step
                    stepModified = true;
                }
                break;

            case PerformanceFX::BUILD_UP_16_BAR:
                // Gradually increases tempo/pitch over 16 bars
                static int buildUpCounter = 0;
                buildUpCounter++;
                if (buildUpCounter < 256) {  // 16 bars * 16 steps
                    // Occasionally skip steps to create build-up effect
                    if (buildUpCounter % 32 == 0) {
                        tempStep = nextStep;  // Repeat occasionally
                        stepModified = true;
                    }
                } else {
                    buildUpCounter = 0;  // Reset after 16 bars
                }
                break;

            case PerformanceFX::RETRIGGER_PATTERN:
                // Random step jumps (reduced probability when stacked)
                if (rand() % (8 * static_cast<int>(performanceFX.activeEffects.size())) == 0) {
                    tempStep = rand() % 16;  // Jump to random step
                    stepModified = true;
                }
                break;

            case PerformanceFX::QUANTIZE_6_8:
                {
                    // 6/8 time - skip steps to create triplet feel
                    static int sixEightPattern[] = {0, 2, 4, 6, 8, 10}; // Only trigger on these steps
                    static int sixEightIndex = 0;

                    // Find closest 6/8 quantized step
                    int closestIndex = 0;
                    int minDistance = 16;
                    for (int i = 0; i < 6; i++) {
                        int distance = abs(nextStep - sixEightPattern[i]);
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestIndex = i;
                        }
                    }
                    sixEightIndex = (closestIndex + 1) % 6;
                    tempStep = sixEightPattern[sixEightIndex];
                    stepModified = true;
                    break;
                }

            default:
                break;
        }

        // Apply the effect with intensity weighting
        if (stepModified) {
            // Blend between original and effected step based on intensity
            nextStep = static_cast<int>(nextStep * (1.0f - intensity) + tempStep * intensity) % 16;
        }
    }

    // If no effects modified the step, use normal progression
    if (!stepModified) {
        return (currentStep + 1) % 16;
    }

    return nextStep;
}

// Global function to process audio effects (supports stacking)
void processAudioEffects(float* audioBuffer, size_t bufferSize) {
    if (!performanceFX.hasActiveEffects()) return;

    // Create temporary buffers for effect processing
    static std::vector<float> tempBuffer;
    tempBuffer.resize(bufferSize);

    // Copy original audio for blending
    std::copy(audioBuffer, audioBuffer + bufferSize, tempBuffer.begin());

    // Apply each active effect in sequence
    for (auto effect : performanceFX.activeEffects) {
        float intensity = performanceFX.effectIntensities.at(effect) * 0.4f; // Reduced for stacking

        switch (effect) {

            case PerformanceFX::STUTTER_SWEEP: {
                // Gentle volume tremolo - much softer like 6/8 Quantize
                for (size_t i = 0; i < bufferSize; i += 2) {
                    performanceFX.stutterCounter++;
                    float cycle = (performanceFX.stutterCounter % 64) / 64.0f; // Slower sweep
                    float gate = (sin(cycle * M_PI * 2) * 0.3f + 0.7f); // Gentle oscillation
                    gate = 0.7f + gate * 0.3f * intensity; // Much subtler

                    audioBuffer[i] *= gate;
                    audioBuffer[i + 1] *= gate;
                }
                break;
            }

            case PerformanceFX::TRANCE_GATE: {
                // Stepped gate with low-pass filter to remove harshness
                static int gatePattern[] = {1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0};
                static float lpf_left = 0, lpf_right = 0;

                for (size_t i = 0; i < bufferSize; i += 2) {
                    performanceFX.stutterCounter++;
                    int gateIndex = (performanceFX.stutterCounter / 32) % 16;
                    float gate = gatePattern[gateIndex] ? 1.0f : (0.2f + 0.3f * intensity);

                    // Apply gate
                    float gated_left = audioBuffer[i] * gate;
                    float gated_right = audioBuffer[i + 1] * gate;

                    // Simple low-pass filter to remove harshness
                    float cutoff = 0.8f - intensity * 0.3f; // Lower cutoff with more intensity
                    lpf_left = lpf_left * cutoff + gated_left * (1.0f - cutoff);
                    lpf_right = lpf_right * cutoff + gated_right * (1.0f - cutoff);

                    audioBuffer[i] = lpf_left;
                    audioBuffer[i + 1] = lpf_right;
                }
                break;
            }

            case PerformanceFX::HALF_RATE: {
                // Halves speed and pitch - creates choppy effect
                for (size_t i = 0; i < bufferSize; i += 2) {
                    performanceFX.scratchPosition++;
                    if (performanceFX.scratchPosition % 2 == 0) {
                        // Keep current sample
                    } else {
                        // Hold previous sample to simulate half rate
                        if (i > 0) {
                            audioBuffer[i] = audioBuffer[i-2];
                            audioBuffer[i+1] = audioBuffer[i-1];
                        }
                    }
                }
                break;
            }

            case PerformanceFX::BUILD_UP_16_BAR: {
                // Ramps up pitch and intensity over time
                static int buildCounter = 0;
                buildCounter++;
                float buildAmount = (buildCounter % 2048) / 2048.0f; // 16 bars worth
                float filterAmount = sin(buildCounter * 0.01f * buildAmount) * intensity;

                for (size_t i = 0; i < bufferSize; i += 2) {
                    // Simple high-pass filtering effect
                    float filtered = audioBuffer[i] * (0.7f + filterAmount * 0.3f);
                    audioBuffer[i] = audioBuffer[i] * 0.7f + filtered * 0.3f;
                    audioBuffer[i + 1] = audioBuffer[i + 1] * 0.7f + filtered * 0.3f;
                }
                break;
            }


            case PerformanceFX::LOOP_16:
            case PerformanceFX::LOOP_12:
            case PerformanceFX::LOOP_SHORT:
            case PerformanceFX::LOOP_SHORTER:
            case PerformanceFX::LOOP_16_DOUBLE:
            case PerformanceFX::LOOP_12_DOUBLE:
            case PerformanceFX::LOOP_SHORT_DOUBLE:
            case PerformanceFX::LOOP_SHORTER_DOUBLE: {
                // Clean audio looping - different buffer sizes for each loop type
                static const int LOOP_BUFFER_SIZE_16 = 512;   // Shortest loops
                static const int LOOP_BUFFER_SIZE_12 = 768;   // Medium loops
                static const int LOOP_BUFFER_SIZE_SHORT = 1024; // Longer loops
                static const int LOOP_BUFFER_SIZE_SHORTER = 1536; // Longest loops

                // Separate buffers for each loop type to avoid interference
                static float loop16_left[LOOP_BUFFER_SIZE_16] = {0};
                static float loop16_right[LOOP_BUFFER_SIZE_16] = {0};
                static float loop12_left[LOOP_BUFFER_SIZE_12] = {0};
                static float loop12_right[LOOP_BUFFER_SIZE_12] = {0};
                static float loopShort_left[LOOP_BUFFER_SIZE_SHORT] = {0};
                static float loopShort_right[LOOP_BUFFER_SIZE_SHORT] = {0};
                static float loopShorter_left[LOOP_BUFFER_SIZE_SHORTER] = {0};
                static float loopShorter_right[LOOP_BUFFER_SIZE_SHORTER] = {0};

                // Double-time buffers (same sizes but separate instances)
                static float loop16Double_left[LOOP_BUFFER_SIZE_16] = {0};
                static float loop16Double_right[LOOP_BUFFER_SIZE_16] = {0};
                static float loop12Double_left[LOOP_BUFFER_SIZE_12] = {0};
                static float loop12Double_right[LOOP_BUFFER_SIZE_12] = {0};
                static float loopShortDouble_left[LOOP_BUFFER_SIZE_SHORT] = {0};
                static float loopShortDouble_right[LOOP_BUFFER_SIZE_SHORT] = {0};
                static float loopShorterDouble_left[LOOP_BUFFER_SIZE_SHORTER] = {0};
                static float loopShorterDouble_right[LOOP_BUFFER_SIZE_SHORTER] = {0};

                static int writePos16 = 0, writePos12 = 0, writePosShort = 0, writePosShorter = 0;
                static int writePos16Double = 0, writePos12Double = 0, writePosShortDouble = 0, writePosShorterDouble = 0;
                static int samplesCollected16 = 0, samplesCollected12 = 0, samplesCollectedShort = 0, samplesCollectedShorter = 0;
                static int samplesCollected16Double = 0, samplesCollected12Double = 0, samplesCollectedShortDouble = 0, samplesCollectedShorterDouble = 0;

                // CRITICAL: Stop the write position from advancing once buffer is full
                // This ensures we keep looping the same captured segment
                static bool loop16Locked = false, loop12Locked = false, loopShortLocked = false, loopShorterLocked = false;
                static bool loop16DoubleLocked = false, loop12DoubleLocked = false, loopShortDoubleLocked = false, loopShorterDoubleLocked = false;

                // Select buffers based on effect type
                float *leftBuf, *rightBuf;
                int *writePos, *samplesCollected, bufferSize_local;
                bool *lockedPtr;

                switch (effect) {
                    case PerformanceFX::LOOP_16:
                        leftBuf = loop16_left; rightBuf = loop16_right;
                        writePos = &writePos16; samplesCollected = &samplesCollected16;
                        bufferSize_local = LOOP_BUFFER_SIZE_16;
                        lockedPtr = &loop16Locked;
                        break;
                    case PerformanceFX::LOOP_12:
                        leftBuf = loop12_left; rightBuf = loop12_right;
                        writePos = &writePos12; samplesCollected = &samplesCollected12;
                        bufferSize_local = LOOP_BUFFER_SIZE_12;
                        lockedPtr = &loop12Locked;
                        break;
                    case PerformanceFX::LOOP_SHORT:
                        leftBuf = loopShort_left; rightBuf = loopShort_right;
                        writePos = &writePosShort; samplesCollected = &samplesCollectedShort;
                        bufferSize_local = LOOP_BUFFER_SIZE_SHORT;
                        lockedPtr = &loopShortLocked;
                        break;
                    case PerformanceFX::LOOP_SHORTER:
                        leftBuf = loopShorter_left; rightBuf = loopShorter_right;
                        writePos = &writePosShorter; samplesCollected = &samplesCollectedShorter;
                        bufferSize_local = LOOP_BUFFER_SIZE_SHORTER;
                        lockedPtr = &loopShorterLocked;
                        break;
                    case PerformanceFX::LOOP_16_DOUBLE:
                        leftBuf = loop16Double_left; rightBuf = loop16Double_right;
                        writePos = &writePos16Double; samplesCollected = &samplesCollected16Double;
                        bufferSize_local = LOOP_BUFFER_SIZE_16;
                        lockedPtr = &loop16DoubleLocked;
                        break;
                    case PerformanceFX::LOOP_12_DOUBLE:
                        leftBuf = loop12Double_left; rightBuf = loop12Double_right;
                        writePos = &writePos12Double; samplesCollected = &samplesCollected12Double;
                        bufferSize_local = LOOP_BUFFER_SIZE_12;
                        lockedPtr = &loop12DoubleLocked;
                        break;
                    case PerformanceFX::LOOP_SHORT_DOUBLE:
                        leftBuf = loopShortDouble_left; rightBuf = loopShortDouble_right;
                        writePos = &writePosShortDouble; samplesCollected = &samplesCollectedShortDouble;
                        bufferSize_local = LOOP_BUFFER_SIZE_SHORT;
                        lockedPtr = &loopShortDoubleLocked;
                        break;
                    case PerformanceFX::LOOP_SHORTER_DOUBLE:
                        leftBuf = loopShorterDouble_left; rightBuf = loopShorterDouble_right;
                        writePos = &writePosShorterDouble; samplesCollected = &samplesCollectedShorterDouble;
                        bufferSize_local = LOOP_BUFFER_SIZE_SHORTER;
                        lockedPtr = &loopShorterDoubleLocked;
                        break;
                    default: return; // Should never happen
                }

                for (size_t i = 0; i < bufferSize; i += 2) {
                    float left = audioBuffer[i];
                    float right = audioBuffer[i + 1];

                    // Always store new samples in loop buffer for fresh audio
                    leftBuf[*writePos] = left;
                    rightBuf[*writePos] = right;
                    *writePos = (*writePos + 1) % bufferSize_local;

                    if (*samplesCollected < bufferSize_local) {
                        (*samplesCollected)++;
                        // During fill period, pass through original
                        audioBuffer[i] = left;
                        audioBuffer[i + 1] = right;
                    } else {
                        // Buffer is full, now loop the audio at normal speed
                        // FIXED: For continuous looping, the read position must cycle independently from write position
                        static int loop16ReadPos = 0, loop12ReadPos = 0, loopShortReadPos = 0, loopShorterReadPos = 0;
                        static int loop16DoubleReadPos = 0, loop12DoubleReadPos = 0, loopShortDoubleReadPos = 0, loopShorterDoubleReadPos = 0;

                        int *readPosPtr;
                        switch (effect) {
                            case PerformanceFX::LOOP_16:
                                readPosPtr = &loop16ReadPos;
                                break;
                            case PerformanceFX::LOOP_12:
                                readPosPtr = &loop12ReadPos;
                                break;
                            case PerformanceFX::LOOP_SHORT:
                                readPosPtr = &loopShortReadPos;
                                break;
                            case PerformanceFX::LOOP_SHORTER:
                                readPosPtr = &loopShorterReadPos;
                                break;
                            case PerformanceFX::LOOP_16_DOUBLE:
                                readPosPtr = &loop16DoubleReadPos;
                                break;
                            case PerformanceFX::LOOP_12_DOUBLE:
                                readPosPtr = &loop12DoubleReadPos;
                                break;
                            case PerformanceFX::LOOP_SHORT_DOUBLE:
                                readPosPtr = &loopShortDoubleReadPos;
                                break;
                            case PerformanceFX::LOOP_SHORTER_DOUBLE:
                                readPosPtr = &loopShorterDoubleReadPos;
                                break;
                            default:
                                readPosPtr = &loop16ReadPos;
                                break;
                        }

                        // Initialize read position to lag behind write position once buffer is full
                        if (!*lockedPtr) {
                            *lockedPtr = true;
                            // Set read position to lag behind write for proper loop timing
                            *readPosPtr = (*writePos - bufferSize_local + bufferSize_local) % bufferSize_local;
                        }

                        // Read from buffer position that lags behind write position
                        float loopedLeft = leftBuf[*readPosPtr];
                        float loopedRight = rightBuf[*readPosPtr];

                        // Advance read position to maintain the loop
                        *readPosPtr = (*readPosPtr + 1) % bufferSize_local;

                        // Mix looped audio with original - clean blend
                        float mixAmount = intensity * 0.9f; // Higher mix for more obvious looping
                        audioBuffer[i] = left * (1.0f - mixAmount) + loopedLeft * mixAmount;
                        audioBuffer[i + 1] = right * (1.0f - mixAmount) + loopedRight * mixAmount;
                    }
                }
                break;
            }

            case PerformanceFX::REVERSE: {
                // Clean real-time audio reversal - simplified approach
                static const int REVERSE_BUFFER_SIZE = 512; // Smaller buffer for lower latency
                static float leftBuffer[REVERSE_BUFFER_SIZE] = {0};
                static float rightBuffer[REVERSE_BUFFER_SIZE] = {0};
                static int writePos = 0;
                static int samplesCollected = 0;

                for (size_t i = 0; i < bufferSize; i += 2) {
                    float left = audioBuffer[i];
                    float right = audioBuffer[i + 1];

                    // Always store samples
                    leftBuffer[writePos] = left;
                    rightBuffer[writePos] = right;
                    writePos = (writePos + 1) % REVERSE_BUFFER_SIZE;

                    if (samplesCollected < REVERSE_BUFFER_SIZE) {
                        samplesCollected++;
                        // Pass through original during fill
                        audioBuffer[i] = left;
                        audioBuffer[i + 1] = right;
                    } else {
                        // Simple reverse read - go backwards from current write position
                        int reverseOffset = (int)(intensity * REVERSE_BUFFER_SIZE * 0.8f); // 0-80% of buffer
                        int readPos = (writePos - reverseOffset + REVERSE_BUFFER_SIZE) % REVERSE_BUFFER_SIZE;

                        float reversedLeft = leftBuffer[readPos];
                        float reversedRight = rightBuffer[readPos];

                        // Gentle mix to avoid distortion
                        float mixAmount = intensity * 0.5f;
                        audioBuffer[i] = left * (1.0f - mixAmount) + reversedLeft * mixAmount;
                        audioBuffer[i + 1] = right * (1.0f - mixAmount) + reversedRight * mixAmount;
                    }
                }
                break;
            }

            case PerformanceFX::SCRATCH: {
                // Clean scratch effect - simple ping-pong through small buffer
                static const int SCRATCH_BUFFER_SIZE = 128; // Very small for fast scratching
                static float scratchLeftBuffer[SCRATCH_BUFFER_SIZE] = {0};
                static float scratchRightBuffer[SCRATCH_BUFFER_SIZE] = {0};
                static int scratchWritePos = 0;
                static int scratchSamplesCollected = 0;
                static float scratchReadPos = 0.0f; // Float for smooth scanning
                static float scratchDirection = 1.0f; // 1.0 = forward, -1.0 = reverse

                for (size_t i = 0; i < bufferSize; i += 2) {
                    float left = audioBuffer[i];
                    float right = audioBuffer[i + 1];

                    // Always store fresh audio
                    scratchLeftBuffer[scratchWritePos] = left;
                    scratchRightBuffer[scratchWritePos] = right;
                    scratchWritePos = (scratchWritePos + 1) % SCRATCH_BUFFER_SIZE;

                    if (scratchSamplesCollected < SCRATCH_BUFFER_SIZE) {
                        scratchSamplesCollected++;
                        // During fill, pass through
                        audioBuffer[i] = left;
                        audioBuffer[i + 1] = right;
                    } else {
                        // Scratch by scanning through buffer at variable speed
                        float scratchSpeed = 3.0f + intensity * 5.0f; // 3x to 8x speed based on intensity
                        scratchReadPos += scratchDirection * scratchSpeed;

                        // Bounce at buffer boundaries
                        if (scratchReadPos >= SCRATCH_BUFFER_SIZE - 1) {
                            scratchReadPos = SCRATCH_BUFFER_SIZE - 1;
                            scratchDirection = -1.0f;
                        } else if (scratchReadPos <= 0) {
                            scratchReadPos = 0;
                            scratchDirection = 1.0f;
                        }

                        // Linear interpolation for smooth scratching
                        int readIdx = (int)scratchReadPos;
                        float frac = scratchReadPos - readIdx;
                        int nextIdx = (readIdx + 1) % SCRATCH_BUFFER_SIZE;

                        float scratchedLeft = scratchLeftBuffer[readIdx] * (1.0f - frac) + scratchLeftBuffer[nextIdx] * frac;
                        float scratchedRight = scratchRightBuffer[readIdx] * (1.0f - frac) + scratchRightBuffer[nextIdx] * frac;

                        // Clean mix
                        float mixAmount = intensity * 0.8f;
                        audioBuffer[i] = left * (1.0f - mixAmount) + scratchedLeft * mixAmount;
                        audioBuffer[i + 1] = right * (1.0f - mixAmount) + scratchedRight * mixAmount;
                    }
                }
                break;
            }

            default:
                break;
        }
    }

    // Normalize volume to prevent clipping when stacking multiple effects
    float stackingFactor = 1.0f / std::max(1.0f, static_cast<float>(performanceFX.activeEffects.size()) * 0.5f);
    for (size_t i = 0; i < bufferSize; i++) {
        audioBuffer[i] *= stackingFactor;
    }
}

// PortAudio callback (same as before)
int audioCallback(const void* /*inputBuffer*/, void* outputBuffer,
                 unsigned long framesPerBuffer,
                 const PaStreamCallbackTimeInfo* /*timeInfo*/,
                 PaStreamCallbackFlags /*statusFlags*/,
                 void* /*userData*/) {
    
    float* out = static_cast<float*>(outputBuffer);
    
    for (unsigned long i = 0; i < framesPerBuffer * 2; i++) {
        out[i] = 0.0f;
    }
    
    for (int engine = 0; engine < MAX_ENGINES; engine++) {
        for (int step = 0; step < 16; step++) {
            if (stepTrigger[engine][step].exchange(false)) {
                if (enginePatterns[engine][step].active) {
                    int slot = rowToSlot[engine]; if (slot < 0) slot = 0;
                    ether_set_active_instrument(etherEngine, slot);

                    int note = enginePatterns[engine][step].note;
                    float velocity = enginePatterns[engine][step].velocity;

                    // Apply 303-style accent effect
                    if (enginePatterns[engine][step].hasAccent) {
                        // Save current filter settings
                        float currentCutoff = ether_get_instrument_parameter(etherEngine, slot, static_cast<int>(ParameterID::FILTER_CUTOFF));
                        float currentResonance = ether_get_instrument_parameter(etherEngine, slot, static_cast<int>(ParameterID::FILTER_RESONANCE));

                        // Apply accent boost to filter (opens cutoff significantly + adds resonance)
                        float accentCutoff = std::min(1.0f, currentCutoff + 0.3f);  // Boost cutoff
                        float accentResonance = std::min(1.0f, currentResonance + 0.2f);  // Add resonance

                        ether_set_instrument_parameter(etherEngine, slot, static_cast<int>(ParameterID::FILTER_CUTOFF), accentCutoff);
                        ether_set_instrument_parameter(etherEngine, slot, static_cast<int>(ParameterID::FILTER_RESONANCE), accentResonance);

                        // Slight volume boost too
                        velocity = std::min(1.0f, velocity * 1.2f);
                    }

                    ether_note_on(etherEngine, note, velocity, 0.0f);
                    activeNotes[engine][step] = note;

                    // Apply step effects (mutually exclusive - retrigger OR arpeggiator, not both)
                    if (enginePatterns[engine][step].hasRetrigger && !enginePatterns[engine][step].hasArpeggiator) {
                        // RETRIGGER EFFECT: Rapid repeated triggers with octave shifts
                        int numTriggers = retriggerSettings.numTriggers - 1; // -1 because we already triggered once
                        float octaveStep = retriggerSettings.octaveShift / static_cast<float>(retriggerSettings.numTriggers - 1);

                        // Calculate dynamic velocity curve based on velocity mode
                        auto calculateVelocity = [&](int triggerIndex, int totalTriggers, float baseVelocity) -> float {
                            float progress = static_cast<float>(triggerIndex) / static_cast<float>(totalTriggers - 1);

                            switch (retriggerSettings.velocityMode) {
                                case RetriggerVelocityMode::STATIC:
                                    return baseVelocity * (1.0f - (triggerIndex * 0.15f)); // Original fade
                                case RetriggerVelocityMode::CRESCENDO:
                                    return baseVelocity * (0.3f + 0.7f * progress * retriggerSettings.intensityCurve);
                                case RetriggerVelocityMode::DIMINUENDO:
                                    return baseVelocity * (1.0f - progress * retriggerSettings.intensityCurve);
                                case RetriggerVelocityMode::ACCENT_FIRST:
                                    return triggerIndex == 0 ? baseVelocity : baseVelocity * (0.4f + 0.3f * retriggerSettings.intensityCurve);
                                case RetriggerVelocityMode::ACCENT_LAST:
                                    return triggerIndex == totalTriggers - 1 ? baseVelocity : baseVelocity * (0.4f + 0.3f * retriggerSettings.intensityCurve);
                                default:
                                    return baseVelocity;
                            }
                        };

                        if (isCurrentEngineDrum()) {
                            // DRUM RETRIGGER: Pitch-shift the same drum pad instead of changing notes
                            int drumPad = note % 16; // Map MIDI note to drum pad (0-15)

                            for (int i = 1; i <= numTriggers; i++) {
                                float dynamicVelocity = calculateVelocity(i, retriggerSettings.numTriggers, velocity);
                                float tuneShift = octaveStep * i; // Convert octave shift to tune parameter (-1.0 to +1.0)
                                tuneShift = std::max(-1.0f, std::min(1.0f, tuneShift)); // Clamp tune to valid range

                                // TODO: Dynamic timing - currently fires immediately, should schedule based on timingMode
                                // For ACCELERATING: delays get shorter (1/8, 1/16, 1/32...)
                                // For DECELERATING: delays get longer (1/32, 1/16, 1/8...)
                                // For EXPONENTIAL/LOGARITHMIC: use intensityCurve to modify delay curves

                                // Temporarily adjust drum tune for this trigger
                                ether_drum_set_param(etherEngine, 0, drumPad, 1, tuneShift); // 1 = tune parameter
                                ether_note_on(etherEngine, note, dynamicVelocity, 0.0f); // Same note, pitched drum

                                // Reset drum tune back to center
                                ether_drum_set_param(etherEngine, 0, drumPad, 1, 0.0f);
                            }
                        } else {
                            // MELODIC RETRIGGER: Change note pitch for melodic engines
                            for (int i = 1; i <= numTriggers; i++) {
                                float dynamicVelocity = calculateVelocity(i, retriggerSettings.numTriggers, velocity);
                                int octaveShift = static_cast<int>(octaveStep * i);
                                int retriggeredNote = note + (octaveShift * 12);

                                // Clamp note to valid MIDI range
                                retriggeredNote = std::max(0, std::min(127, retriggeredNote));

                                // TODO: Dynamic timing - same scheduling system as drums
                                ether_note_on(etherEngine, retriggeredNote, dynamicVelocity, 0.0f);
                            }
                        }
                    } else if (enginePatterns[engine][step].hasArpeggiator && !enginePatterns[engine][step].hasRetrigger) {
                        // ARPEGGIATOR EFFECT: Generate arpeggiated sequence based on settings
                        if (isCurrentEngineDrum()) {
                            // DRUM ARPEGGIATOR: Pitch-shift the same drum pad to different tunings
                            int drumPad = note % 16; // Map MIDI note to drum pad (0-15)
                            std::vector<float> arpTunes;

                            // Build pitch variations for drum (tune values from -1.0 to +1.0)
                            float tuneStep = 2.0f / static_cast<float>(arpeggiatorSettings.length - 1); // Spread across range
                            for (int i = 0; i < arpeggiatorSettings.length; i++) {
                                float tuneValue = -1.0f + (i * tuneStep); // From -1.0 to +1.0
                                arpTunes.push_back(std::max(-1.0f, std::min(1.0f, tuneValue)));
                            }

                            // Apply pattern ordering to tune values
                            std::vector<float> finalTunes;
                            switch (arpeggiatorSettings.pattern) {
                                case ArpPattern::UP:
                                    finalTunes = arpTunes;
                                    break;
                                case ArpPattern::DOWN:
                                    finalTunes = arpTunes;
                                    std::reverse(finalTunes.begin(), finalTunes.end());
                                    break;
                                case ArpPattern::UP_DOWN:
                                    finalTunes = arpTunes;
                                    for (int i = arpTunes.size() - 2; i >= 0; i--) {
                                        finalTunes.push_back(arpTunes[i]);
                                    }
                                    break;
                                case ArpPattern::RANDOM:
                                    finalTunes = arpTunes;
                                    {
                                        static std::random_device rd;
                                        static std::mt19937 g(rd());
                                        std::shuffle(finalTunes.begin(), finalTunes.end(), g);
                                    }
                                    break;
                                case ArpPattern::CHORD:
                                    // Play all tuned versions simultaneously (already did root)
                                    for (size_t i = 1; i < arpTunes.size(); i++) {
                                        ether_drum_set_param(etherEngine, 0, drumPad, 1, arpTunes[i]);
                                        ether_note_on(etherEngine, note, velocity * 0.8f, 0.0f);
                                        ether_drum_set_param(etherEngine, 0, drumPad, 1, 0.0f); // Reset
                                    }
                                    finalTunes.clear(); // Don't continue with sequence
                                    break;
                                default:
                                    finalTunes = arpTunes;
                                    break;
                            }

                            // Trigger drum arpeggio sequence
                            if (!finalTunes.empty() && arpeggiatorSettings.pattern != ArpPattern::CHORD) {
                                for (size_t i = 1; i < finalTunes.size(); i++) { // Skip first (already triggered)
                                    float arpVelocity = velocity * (0.9f - (i * 0.1f)); // Slight velocity variation
                                    ether_drum_set_param(etherEngine, 0, drumPad, 1, finalTunes[i]); // Set tune
                                    ether_note_on(etherEngine, note, arpVelocity, 0.0f); // Same note, tuned drum
                                    ether_drum_set_param(etherEngine, 0, drumPad, 1, 0.0f); // Reset tune
                                }
                            }
                        } else {
                            // MELODIC ARPEGGIATOR: Generate chord-based arpeggios
                            std::vector<int> arpNotes;

                            // Build base arpeggio notes (simplified - using major triad for now)
                            arpNotes.push_back(note);                // Root
                            arpNotes.push_back(note + 4);           // Major 3rd
                            arpNotes.push_back(note + 7);           // Perfect 5th
                            if (arpeggiatorSettings.length >= 4) arpNotes.push_back(note + 12); // Octave
                            if (arpeggiatorSettings.length >= 5) arpNotes.push_back(note + 16); // Major 3rd + octave
                            if (arpeggiatorSettings.length >= 6) arpNotes.push_back(note + 19); // Perfect 5th + octave
                            if (arpeggiatorSettings.length >= 7) arpNotes.push_back(note + 24); // 2nd octave
                            if (arpeggiatorSettings.length >= 8) arpNotes.push_back(note + 28); // Major 3rd + 2nd octave

                            // Trim to desired length
                            if (arpNotes.size() > static_cast<size_t>(arpeggiatorSettings.length)) {
                                arpNotes.resize(arpeggiatorSettings.length);
                            }

                            // Apply pattern ordering
                            std::vector<int> finalArp;
                            switch (arpeggiatorSettings.pattern) {
                                case ArpPattern::UP:
                                    finalArp = arpNotes;
                                    break;
                                case ArpPattern::DOWN:
                                    finalArp = arpNotes;
                                    std::reverse(finalArp.begin(), finalArp.end());
                                    break;
                                case ArpPattern::UP_DOWN:
                                    finalArp = arpNotes;
                                    for (int i = arpNotes.size() - 2; i >= 0; i--) {
                                        finalArp.push_back(arpNotes[i]);
                                    }
                                    break;
                                case ArpPattern::RANDOM:
                                    finalArp = arpNotes;
                                    {
                                        static std::random_device rd;
                                        static std::mt19937 g(rd());
                                        std::shuffle(finalArp.begin(), finalArp.end(), g);
                                    }
                                    break;
                                case ArpPattern::CHORD:
                                    // Play all notes simultaneously (already did root note)
                                    for (size_t i = 1; i < arpNotes.size(); i++) {
                                        int arpNote = std::max(0, std::min(127, arpNotes[i]));
                                        ether_note_on(etherEngine, arpNote, velocity * 0.8f, 0.0f);
                                    }
                                    finalArp.clear(); // Don't continue with sequence
                                    break;
                                default:
                                    finalArp = arpNotes;
                                    break;
                            }

                            // Trigger arpeggio sequence (simplified timing)
                            if (!finalArp.empty() && arpeggiatorSettings.pattern != ArpPattern::CHORD) {
                                for (size_t i = 1; i < finalArp.size(); i++) { // Skip first note (already triggered)
                                    int arpNote = std::max(0, std::min(127, finalArp[i]));
                                    float arpVelocity = velocity * (0.9f - (i * 0.1f)); // Slight velocity variation
                                    ether_note_on(etherEngine, arpNote, arpVelocity, 0.0f);
                                }
                            }
                        }
                    }
                }
            }
            
            if (noteOffTrigger[engine][step].exchange(false)) {
                int note = activeNotes[engine][step].exchange(-1);
                if (note >= 0) {
                    int slot = rowToSlot[engine]; if (slot < 0) slot = 0;
                    ether_set_active_instrument(etherEngine, slot);
                    ether_note_off(etherEngine, note);
                }
            }
        }
    }
    
    if (etherEngine) {
        ether_process_audio(etherEngine, out, framesPerBuffer);

        // Apply Performance FX audio effects if active
        if (performanceFX.hasActiveEffects()) {
            processAudioEffects(out, framesPerBuffer * 2);
        }
    }

    return paContinue;
}

class GridSequencer {
private:
    PaStream* stream = nullptr;
    std::thread sequencerThread;
    std::thread ledUpdateThread;
    std::atomic<bool> running{false};
    std::atomic<float> bpm{120.0f};

    // Encoder state - implementing your control architecture
    SerialPort encoderSerial;
    std::string serialLineBuffer;

    // Encoder 4 state (menu navigation + edit mode)
    bool editMode = false;

    // Encoders 1-3 state (parameter latching)
    struct ParameterLatch {
        bool active = false;
        ParameterID paramId;
        std::string paramName;
        int engineRow = -1;  // Store which engine row this parameter is latched to
    };
    ParameterLatch paramLatches[3]; // For encoders 1-3

    // Double-press detection
    struct ButtonState {
        std::chrono::steady_clock::time_point lastPressTime;
        bool pendingSinglePress = false;
    };
    ButtonState buttonStates[4]; // For encoders 1-4
    static constexpr int DOUBLE_PRESS_TIMEOUT_MS = 300;
public:
    // (prototypes consolidated above)
    
    GridSequencer() {
        initializeEnginePatterns();
        initializePatternBank();  // Initialize 16 pattern slots
        setupEncoderSystem(); // Simple connection like encoder_demo
    }
    
    ~GridSequencer() {
        shutdownSequencer();
    }
    
    bool initializeGrid();
    
    bool initialize();
    void showStatus();
    void processPseudoParamLFOs();

    // Performance FX System methods
    void initializeEffect(PerformanceFX effect);
    void processPatternEffects();
    void deactivateEffect();

    void run();
    void play();
    void stop();
    void clearPattern();
    void shutdownSequencer();

    // Encoder control system methods
    void setupEncoderSystem();
    void updateEngineFromEncoderChange(const std::string& param_id, float delta);
    void syncMenuWithEncoder(const std::string& param_id);
    void processEncoderInput();
    void handleEncoder4Turn(int delta);
    void handleParameterEncoderTurn(int encoder_id, int delta);
    void handleEncoderButtonPress(int encoder_id);
    void updateButtonTimers();
    void processPendingButtonPress(int encoder_id);
    void handleEncoderLatch(int encoder_id);
    void adjustLatchedParameter(int enc_index, int delta);

    // Direct encoder parameter control
    struct EncoderLatch {
        bool active = false;
        int paramIndex = -1;  // Index into visibleParams
        std::string paramName;
    };
    EncoderLatch encoderLatches[4];  // For encoders 1-4
};

    /* BEGIN_OLD_INCLASS
        std::cout << "\n=== EtherSynth Grid Sequencer ===" << std::endl;
        std::cout << "Grid: " << (gridConnected ? "Connected" : "Disconnected") << std::endl;
        
        const char* engineName = currentInstrumentTypeName();
        std::cout << "Current Engine Row: " << currentEngineRow << " (" << (engineName ? engineName : "Unknown") << ")" << std::endl;
        std::cout << "BPM: " << std::fixed << std::setprecision(1) << bpm.load();
        std::cout << " | " << (playing ? "PLAYING" : "STOPPED");
        if (playing) {
            std::cout << " | Step: " << (currentStep + 1) << "/16";
        }
        std::cout << std::endl;
        
        // Show current engine's pattern
        std::cout << "Pattern [" << currentEngineRow << "]: ";
        for (int i = 0; i < 16; i++) {
            if (enginePatterns[currentEngineRow][i].active) {
                if (i == currentStep && playing) {
                    std::cout << "[" << (i+1) << "]";
                } else {
                    std::cout << " " << (i+1) << " ";
                }
            } else {
                if (i == currentStep && playing) {
                    std::cout << "[·]";
                } else {
                    std::cout << " · ";
                }
            }
        }
        std::cout << std::endl;
    }
    
    // Removed broken duplicate run() function - using GridSequencer::run() instead
                if (c == 'q') { quit = true; break; }
                if (c == ' ') { reqTogglePlay = true; }
                if (c == 'w' || c == 'W') { writeMode = !writeMode.load(); }
                if (c == 'c' || c == 'C') { reqClear = true; }
                if (c == 'a' || c == 'A') { playAllEngines = !playAllEngines.load(); }
                if (c == '[') { if (--selectedLFOIndex < 0) selectedLFOIndex = 0; }
                if (c == ']') { if (++selectedLFOIndex > 7) selectedLFOIndex = 7; }
                if (c == 'L') {
                    showLFOAssign = !showLFOAssign;
                    // refresh local mask from engine
                    if (showLFOAssign && selectedParamIndex < (int)extendedVisibleParams.size()) {
                        int activeMask = 0; float cur = 0.0f;
                        int slot = rowToSlot[currentEngineRow]; if (slot < 0) slot = 0;
                        int pid = getExtendedParameterId(selectedParamIndex);
                        if (pid != -1 && pid != PSEUDO_PARAM_OCTAVE && pid != PSEUDO_PARAM_PITCH) {
                            ether_get_parameter_lfo_info(etherEngine, slot, pid, &activeMask, &cur);
                        }
                        lfoAssignMask = static_cast<uint32_t>(activeMask);
                        lfoAssignCursor = 0;
                    }
                }
                if (c == 'S') { showLFOSettings = !showLFOSettings; }
                if (c == 'v' || c == 'V') {
                    int wf = (lfoWaveform[selectedLFOIndex] + 1) % 12; // cycle 0..11
                    lfoWaveform[selectedLFOIndex] = wf;
                    int slot = rowToSlot[currentEngineRow]; if (slot < 0) slot = 0;
                    ether_set_lfo_waveform(etherEngine, (unsigned char)selectedLFOIndex, (unsigned char)wf);
                }
                if (c == 'r') {
                    lfoRate[selectedLFOIndex] = std::max(0.01f, lfoRate[selectedLFOIndex] * 0.9f);
                    int slot = rowToSlot[currentEngineRow]; if (slot < 0) slot = 0;
                    ether_set_lfo_rate(etherEngine, (unsigned char)selectedLFOIndex, lfoRate[selectedLFOIndex]);
                }
                if (c == 'R') {
                    lfoRate[selectedLFOIndex] = std::min(50.0f, lfoRate[selectedLFOIndex] * 1.1f);
                    int slot = rowToSlot[currentEngineRow]; if (slot < 0) slot = 0;
                    ether_set_lfo_rate(etherEngine, (unsigned char)selectedLFOIndex, lfoRate[selectedLFOIndex]);
                }
                if (c == 'd') {
                    lfoDepth[selectedLFOIndex] = std::max(0.0f, lfoDepth[selectedLFOIndex] - 0.05f);
                    int slot = rowToSlot[currentEngineRow]; if (slot < 0) slot = 0;
                    ether_set_lfo_depth(etherEngine, (unsigned char)selectedLFOIndex, lfoDepth[selectedLFOIndex]);
                }
                if (c == 'D') {
                    lfoDepth[selectedLFOIndex] = std::min(1.0f, lfoDepth[selectedLFOIndex] + 0.05f);
                    int slot = rowToSlot[currentEngineRow]; if (slot < 0) slot = 0;
                    ether_set_lfo_depth(etherEngine, (unsigned char)selectedLFOIndex, lfoDepth[selectedLFOIndex]);
                }
                if (c == 'm') {
                    // Quick-assign selected LFO to current parameter
                    if (selectedParamIndex < (int)extendedVisibleParams.size()) {
                        int pid = getExtendedParameterId(selectedParamIndex);
                        if (pid != -1 && pid != PSEUDO_PARAM_OCTAVE && pid != PSEUDO_PARAM_PITCH) {
                            int slot = rowToSlot[currentEngineRow]; if (slot < 0) slot = 0;
                            ether_assign_lfo_to_param_id(etherEngine, slot, selectedLFOIndex, pid, lfoDepth[selectedLFOIndex]);
                            lfoAssignMask |= (1u << selectedLFOIndex);
                        }
                    }
                }
                if (c == 'M') {
                    // Quick-remove selected LFO from current parameter
                    if (selectedParamIndex < (int)extendedVisibleParams.size()) {
                        int pid = getExtendedParameterId(selectedParamIndex);
                        if (pid != -1 && pid != PSEUDO_PARAM_OCTAVE && pid != PSEUDO_PARAM_PITCH) {
                            int slot = rowToSlot[currentEngineRow]; if (slot < 0) slot = 0;
                            ether_remove_lfo_assignment_by_param(etherEngine, slot, selectedLFOIndex, pid);
                            lfoAssignMask &= ~(1u << selectedLFOIndex);
                        }
                    }
                }
                if (c == 'e' || c == 'E') {
                    // Envelope mode latch for selected LFO
                    int slot = rowToSlot[currentEngineRow]; if (slot < 0) slot = 0;
                    ether_set_lfo_sync(etherEngine, slot, selectedLFOIndex, 4); // ENVELOPE
                }
                if (c == 'k' || c == 'K') {
                    // Key-sync mode for selected LFO (restarts on key)
                    int slot = rowToSlot[currentEngineRow]; if (slot < 0) slot = 0;
                    ether_set_lfo_sync(etherEngine, slot, selectedLFOIndex, 2); // KEY_SYNC
                }
                if (isCurrentEngineDrum()) {
                    if (c == '[') { if (--drumEditPad < 0) drumEditPad = 0; }
                    if (c == ']') { if (++drumEditPad > 15) drumEditPad = 15; }
                    if (c == '\n') { drumEditField = (drumEditField+1)%4; }
                }
                // Vim-style unified navigation (matches arrow key behavior)
                if (c == 'j') {
                    if (showLFOAssign) {
                        lfoAssignCursor = std::min(7, lfoAssignCursor + 1);
                    } else {
                        int maxIdx = (int)extendedVisibleParams.size() + extraMenuRows();
                        int idx = selectedParamIndex + 1; if (idx > maxIdx) idx = maxIdx; selectedParamIndex = idx;
                    }
                } else if (c == 'k') {
                    if (showLFOAssign) {
                        lfoAssignCursor = std::max(0, lfoAssignCursor - 1);
                    } else {
                        int maxIdx = (int)extendedVisibleParams.size() + extraMenuRows();
                        int idx = selectedParamIndex - 1; if (idx < 0) idx = 0; selectedParamIndex = idx;
                    }
                } else if (c == '\x1b') { // ESC sequence
                    char seq[2];
                    if (read(STDIN_FILENO, &seq[0], 1) != 1) break;
                    if (read(STDIN_FILENO, &seq[1], 1) != 1) break;
                    if (seq[0] == '[') {
                if (seq[1] == 'A') { // Up - unified menu navigation
                    if (showLFOAssign) {
                        lfoAssignCursor = std::max(0, lfoAssignCursor - 1);
                    } else {
                        int maxIdx = (int)extendedVisibleParams.size() + extraMenuRows();
                        int idx = selectedParamIndex - 1; if (idx < 0) idx = 0; selectedParamIndex = idx;
                    }
                } else if (seq[1] == 'B') { // Down - unified menu navigation
                    if (showLFOAssign) {
                        lfoAssignCursor = std::min(7, lfoAssignCursor + 1);
                    } else {
                        int maxIdx = (int)extendedVisibleParams.size() + extraMenuRows();
                        int idx = selectedParamIndex + 1; if (idx > maxIdx) idx = maxIdx; selectedParamIndex = idx;
                    }
                        } else if (seq[1] == 'C') { // Right
                            if (showLFOAssign) {
                                lfoAssignCursor = std::min(7, lfoAssignCursor + 1);
                                break;
                            }
                            if (isCurrentEngineDrum() && selectedParamIndex == (int)extendedVisibleParams.size()+1) {
                                // adjust drum field
                                float step = (drumEditField==1) ? 0.05f : 0.02f;
                                ether_drum_set_param(etherEngine, 0, drumEditPad, drumEditField, step +  (drumEditField==1?0.0f:0.0f));
                            } else if (selectedParamIndex < (int)extendedVisibleParams.size()) {
                                int pid = getExtendedParameterId(selectedParamIndex);
                                if (pid == -1) break;
                                adjustParameter(pid, true); // Clean increment call
                            } else {
                                int base = (int)extendedVisibleParams.size();
                                if (selectedParamIndex == base) {
                                    int voices = ether_get_engine_voice_count(etherEngine, 0);
                                    voices = std::min(16, voices + 1);
                                    ether_set_engine_voice_count(etherEngine, 0, voices);
                                } else if (selectedParamIndex == base+1) {
                                    float v = std::min(1.0f, ether_get_engine_fx_send(etherEngine, currentEngineRow, 0) + 0.02f);
                                    ether_set_engine_fx_send(etherEngine, currentEngineRow, 0, v);
                                } else if (selectedParamIndex == base+2) {
                                    float v = std::min(1.0f, ether_get_engine_fx_send(etherEngine, currentEngineRow, 1) + 0.02f);
                                    ether_set_engine_fx_send(etherEngine, currentEngineRow, 1, v);
                                } else if (selectedParamIndex >= base+3 && selectedParamIndex <= base+8) {
                                    int which = (selectedParamIndex<=base+5)?0:1;
                                    int param = (selectedParamIndex-(base+3)) % 3;
                                    float cur = ether_get_fx_global(etherEngine, which, param);
                                    ether_set_fx_global(etherEngine, which, param, std::min(1.0f, cur+0.02f));
                                }
                            }
                        } else if (seq[1] == 'D') { // Left
                            if (showLFOAssign) {
                                lfoAssignCursor = std::max(0, lfoAssignCursor - 1);
                                break;
                            }
                            if (isCurrentEngineDrum() && selectedParamIndex == (int)extendedVisibleParams.size()+1) {
                                float step = (drumEditField==1) ? -0.05f : -0.02f;
                                ether_drum_set_param(etherEngine, 0, drumEditPad, drumEditField, step + 0.0f);
                            } else if (selectedParamIndex < (int)extendedVisibleParams.size()) {
                                int pid = getExtendedParameterId(selectedParamIndex);
                                if (pid == -1) break;
                                adjustParameter(pid, false); // Clean decrement call
                            } else {
                                int base = (int)extendedVisibleParams.size();
                                if (selectedParamIndex == base) {
                                    int voices = ether_get_engine_voice_count(etherEngine, 0);
                                    voices = std::max(1, voices - 1);
                                    ether_set_engine_voice_count(etherEngine, 0, voices);
                                } else if (selectedParamIndex == base+1) {
                                    float v = std::max(0.0f, ether_get_engine_fx_send(etherEngine, currentEngineRow, 0) - 0.02f);
                                    ether_set_engine_fx_send(etherEngine, currentEngineRow, 0, v);
                                } else if (selectedParamIndex == base+2) {
                                    float v = std::max(0.0f, ether_get_engine_fx_send(etherEngine, currentEngineRow, 1) - 0.02f);
                                    ether_set_engine_fx_send(etherEngine, currentEngineRow, 1, v);
                                } else if (selectedParamIndex >= base+3 && selectedParamIndex <= base+8) {
                                    int which = (selectedParamIndex<=base+5)?0:1;
                                    int param = (selectedParamIndex-(base+3)) % 3;
                                    float cur = ether_get_fx_global(etherEngine, which, param);
                                    ether_set_fx_global(etherEngine, which, param, std::max(0.0f, cur-0.02f));
                                }
                            }
                        }
                        }
                    }
                }
                if (showLFOAssign && (c == 'x' || c == 'X' || c == '\n')) {
                    if (selectedParamIndex < (int)extendedVisibleParams.size()) {
                        int pid = getExtendedParameterId(selectedParamIndex);
                        if (pid != -1 && pid != PSEUDO_PARAM_OCTAVE && pid != PSEUDO_PARAM_PITCH) {
                            int slot = rowToSlot[currentEngineRow]; if (slot < 0) slot = 0;
                            bool on = ((lfoAssignMask >> lfoAssignCursor) & 1u) != 0;
                            if (on) {
                                ether_remove_lfo_assignment_by_param(etherEngine, slot, lfoAssignCursor, pid);
                                lfoAssignMask &= ~(1u << lfoAssignCursor);
                            } else {
                                ether_assign_lfo_to_param_id(etherEngine, slot, lfoAssignCursor, pid, lfoDepth[lfoAssignCursor]);
                                lfoAssignMask |= (1u << lfoAssignCursor);
                            }
                        }
                    }
                }
            }
            drawFixedUI();
            std::this_thread::sleep_for(std::chrono::milliseconds(50));
        }
        disableRawMode();
        std::cout << "\nGoodbye!" << std::endl;
    }
    
    void play();
        if (!playing) {
            playing = true;
            currentStep = 0;
            std::cout << "✓ Playing all engines" << std::endl;
            
            sequencerThread = std::thread([this]() {
                while (playing) {
                    if (isCurrentEngineDrum()) {
                        // Trigger any drum whose bit at currentStep is set; let engine manage decay
                        int slot = rowToSlot[currentEngineRow]; if (slot < 0) slot = 0;
                        if (!(soloEngine>=0 && currentEngineRow!=soloEngine) && !rowMuted[currentEngineRow]) {
                            ether_set_active_instrument(etherEngine, slot);
                            bool chNow = ((drumMasks[8] >> currentStep) & 1u) || ((drumMasks[9] >> currentStep) & 1u);
                            for (int pad = 0; pad < 16; ++pad) {
                                if ((drumMasks[pad] >> currentStep) & 1u) {
                                    // Skip if we just previewed this pad at this step
                                    int prev = drumPreviewStep[pad].load();
                                    if (prev == currentStep) { drumPreviewStep[pad] = -1; continue; }
                                    if (chNow && pad == 10) continue; // choke OH when CH/PH hit same step
                                    float vel = accentLatch ? 1.0f : 0.9f;
                                    ether_note_on(etherEngine, DRUM_PAD_NOTES[pad], vel, 0.0f);
                                }
                            }
                        }
                    } else {
                        if (playAllEngines) {
                            // Trigger all rows (drums + melodic)
                            for (int s = 0; s < 16; ++s) {
                                int row = slotToRow[s];
                                if (row < 0) continue;
                                if (soloEngine >= 0 && row != soloEngine) continue;
                                if (rowMuted[row]) continue;
                                // Determine if this slot is a drum row by engine type
                                int etype = ether_get_instrument_engine_type(etherEngine, s);
                                bool isDrum = (etype == static_cast<int>(EngineType::DRUM_KIT));
                                if (isDrum) {
                                    // Trigger any drum whose bit at currentStep is set on this row's slot
                                    int slot = s;
                                    ether_set_active_instrument(etherEngine, slot);
                                    bool chNow = ((drumMasks[8] >> currentStep) & 1u) || ((drumMasks[9] >> currentStep) & 1u);
                                    for (int pad = 0; pad < 16; ++pad) {
                                        if ((drumMasks[pad] >> currentStep) & 1u) {
                                            // Skip if we just previewed this pad at this step
                                            int prev = drumPreviewStep[pad].load();
                                            if (prev == currentStep) { drumPreviewStep[pad] = -1; continue; }
                                            if (chNow && pad == 10) continue; // choke OH when CH/PH hit same step
                                            float vel = accentLatch ? 1.0f : 0.9f;
                                            ether_note_on(etherEngine, DRUM_PAD_NOTES[pad], vel, 0.0f);
                                        }
                                    }
                                } else {
                                    if (enginePatterns[row][currentStep].active) {
                                        // Skip if just previewed live in this step
                                        int prev = melodicPreviewStep[row].load();
                                        if (prev == currentStep) { melodicPreviewStep[row] = -1; }
                                        else { stepTrigger[row][currentStep] = true; }
                                    }
                                }
                            }
                            // Schedule melodic note offs only (drums manage decay)
                            std::thread([this]() {
                                float stepMs = (60.0f / bpm) / 4.0f * 1000.0f;
                                for (int s = 0; s < 16; ++s) {
                                    int row = slotToRow[s]; if (row < 0) continue;
                                    if (soloEngine >= 0 && row != soloEngine) continue;
                                    if (rowMuted[row]) continue;
                                    int etype = ether_get_instrument_engine_type(etherEngine, s);
                                    bool isDrum = (etype == static_cast<int>(EngineType::DRUM_KIT));
                                    if (!isDrum) {
                                        float releaseParam = engineParameters[row][static_cast<int>(ParameterID::RELEASE)];
                                        float noteOffMs = stepMs * (0.1f + releaseParam * 0.8f);
                                        std::this_thread::sleep_for(std::chrono::milliseconds(static_cast<int>(noteOffMs)));
                                        if (playing) {
                                            noteOffTrigger[row][currentStep] = true;
                                        }
                                    }
                                }
                            }).detach();
                        } else {
                            int engine = currentEngineRow;
                            if (soloEngine >= 0 && engine != soloEngine) {
                                // skip
                            } else if (!rowMuted[engine] && enginePatterns[engine][currentStep].active) {
                                stepTrigger[engine][currentStep] = true;
                                std::thread([this, engine]() {
                                    float stepMs = (60.0f / bpm) / 4.0f * 1000.0f;
                                    float releaseParam = engineParameters[engine][static_cast<int>(ParameterID::RELEASE)];
                                    float noteOffMs = stepMs * (0.1f + releaseParam * 0.8f);
                                    std::this_thread::sleep_for(std::chrono::milliseconds(static_cast<int>(noteOffMs)));
                                    if (playing) {
                                        noteOffTrigger[engine][currentStep] = true;
                                    }
                                }).detach();
                            }
                        }
                    }

                    // Apply Performance FX to step progression
                    currentStep = getNextStep(currentStep);

                    float stepMs = (60.0f / bpm) / 4.0f * 1000.0f;
                    std::this_thread::sleep_for(std::chrono::milliseconds(static_cast<int>(stepMs)));
                }
            });
        }
    }
    
    void stop();
        if (playing) {
            playing = false;
            ether_all_notes_off(etherEngine);
            if (sequencerThread.joinable()) {
                sequencerThread.join();
            }
            std::cout << "✓ Stopped" << std::endl;
        }
    }
    
    void clearPattern();
        if (isCurrentEngineDrum()) {
            for (auto &m : drumMasks) m = 0;
        } else {
            for (auto& step : enginePatterns[currentEngineRow]) {
                step.active = false;
            }
        }
        const char* name = currentInstrumentTypeName();
        std::cout << "✓ Cleared pattern for " << (name ? name : "Unknown") << std::endl;
    }
    
    void shutdownSequencer();
        if (running) {
            stop();
            running = false;
            
            if (sequencerThread.joinable()) {
                sequencerThread.join();
            }
            
            if (ledUpdateThread.joinable()) {
                ledUpdateThread.join();
            }
            
            if (grid_server) {
                lo_server_thread_stop(grid_server);
                lo_server_thread_free(grid_server);
                grid_server = nullptr;
            }
            
            if (grid_addr) {
                lo_address_free(grid_addr);
                grid_addr = nullptr;
            }
            
            if (stream) {
                Pa_CloseStream(stream);
                stream = nullptr;
            }
            
            Pa_Terminate();
            
            if (etherEngine) {
                ether_shutdown(etherEngine);
                ether_destroy(etherEngine);
                etherEngine = nullptr;
            }
            
            audioRunning = false;
        }
    }
};

};
*/

// ===== GridSequencer method definitions (moved from class) =====

bool GridSequencer::initializeGrid() {
    grid_server = lo_server_thread_new(std::to_string(local_grid_osc_port).c_str(), nullptr);
    if (!grid_server) { std::cout << "Failed to create OSC server" << std::endl; return false; }
    lo_server_thread_add_method(grid_server, (grid_prefix + "/grid/key").c_str(), "iii", grid_key_handler, nullptr);
    lo_server_thread_add_method(grid_server, "/serialosc/device", "ssi", serialosc_device_handler, nullptr);
    lo_server_thread_add_method(grid_server, "/serialosc/add", "ssi", serialosc_device_handler, nullptr);
    lo_server_thread_add_method(grid_server, (grid_prefix + "/sys/port").c_str(), "", [](const char*,const char*, lo_arg**,int, lo_message, void*)->int{ return 0; }, nullptr);
    lo_server_thread_add_method(grid_server, (grid_prefix + "/sys/host").c_str(), "", [](const char*,const char*, lo_arg**,int, lo_message, void*)->int{ return 0; }, nullptr);
    lo_server_thread_add_method(grid_server, (grid_prefix + "/sys/id").c_str(), "", [](const char*,const char*, lo_arg**,int, lo_message, void*)->int{ return 0; }, nullptr);
    lo_server_thread_add_method(grid_server, (grid_prefix + "/sys/size").c_str(), "", [](const char*,const char*, lo_arg**,int, lo_message, void*)->int{ return 0; }, nullptr);
    lo_server_thread_add_method(grid_server, (grid_prefix + "/*").c_str(), nullptr, [](const char*,const char*, lo_arg**,int, lo_message, void*)->int{ return 0; }, nullptr);
    lo_server_thread_start(grid_server);
    grid_addr = lo_address_new("127.0.0.1", "12002");
    lo_send(grid_addr, "/serialosc/list", "si", "127.0.0.1", local_grid_osc_port);
    lo_send(grid_addr, "/serialosc/notify", "si", "127.0.0.1", local_grid_osc_port);
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
    std::this_thread::sleep_for(std::chrono::milliseconds(200));
    std::cout << "Grid setup complete - listening on port " << local_grid_osc_port << std::endl;
    return true;
}

bool GridSequencer::initialize() {
    etherEngine = ether_create();
    if (!etherEngine) return false;
    ether_initialize(etherEngine);
    ether_set_master_volume(etherEngine, 0.8f);
    ether_play(etherEngine);
    for (int r = 0; r < MAX_ENGINES; ++r) rowToSlot[r] = -1;
    for (int s = 0; s < 8; ++s) slotToRow[s] = -1;
    for (int r = 0; r < MAX_ENGINES; ++r) rowToSlot[r] = -1;
    for (int s = 0; s < 16; ++s) slotToRow[s] = -1;
    for (int r = 0; r < 16 && r < MAX_ENGINES; ++r) { rowToSlot[r] = r; slotToRow[r] = r; ether_set_active_instrument(etherEngine, r); ether_set_instrument_engine_type(etherEngine, r, r); }
    int curSlot = (currentEngineRow >= 0 && currentEngineRow < MAX_ENGINES) ? rowToSlot[currentEngineRow] : 0;
    if (curSlot < 0) curSlot = 0; ether_set_active_instrument(etherEngine, curSlot);
    for (int engine = 0; engine < MAX_ENGINES; engine++) { int slot = rowToSlot[engine]; if (slot < 0) continue; ether_set_instrument_engine_type(etherEngine, slot, engine); for (auto& kv : engineParameters[engine]) { ether_set_instrument_parameter(etherEngine, slot, kv.first, kv.second); } }
    rebuildVisibleParams(); // Initialize parameter list after engines are set up
    PaError err = Pa_Initialize(); if (err != paNoError) return false;
    err = Pa_OpenDefaultStream(&stream, 0, 2, paFloat32, 48000, 128, audioCallback, nullptr); if (err != paNoError) return false;
    err = Pa_StartStream(stream); if (err != paNoError) return false;
    audioRunning = true; running = true;
    initializeGrid();
    ledUpdateThread = std::thread([this]() {
        while (running) { if (reqTogglePlay.exchange(false)) { if (!playing) this->play(); else this->stop(); } if (reqClear.exchange(false)) { this->clearPattern(); } updateGridLEDs(); std::this_thread::sleep_for(std::chrono::milliseconds(50)); }
    });
    return true;
}

void GridSequencer::processPseudoParamLFOs() {
    auto now = std::chrono::steady_clock::now();

    for (auto& [paramId, lfo] : pseudoParamLFOs) {
        if (!lfo.active || lfo.lfoIndex < 0 || lfo.lfoIndex >= 8) continue;

        // Use existing LFO system - get current LFO modulation for any parameter
        // We'll use a dummy parameter to get the LFO value
        int activeMask = 0;
        float currentLFOValue = 0.0f;
        int currentSlot = rowToSlot[currentEngineRow];
        if (currentSlot < 0) currentSlot = 0;

        // Get LFO info - this gives us the combined LFO modulation
        ether_get_parameter_lfo_info(etherEngine, currentSlot, 0, &activeMask, &currentLFOValue);

        // Extract modulation for this specific LFO
        float lfoModulation = 0.0f;
        if (activeMask & (1 << lfo.lfoIndex)) {
            // This LFO is active, use a portion of the combined value
            // For simplicity, we'll use the currentLFOValue scaled by our depth
            lfoModulation = currentLFOValue * lfo.depth;
        }

        if (paramId == PSEUDO_PARAM_OCTAVE) {
            // LFO modulates octave in range -2 to +2 octaves
            int baseOctave = octaveOffset.load();
            int modulatedOctave = baseOctave + static_cast<int>(lfoModulation * 2.0f);
            modulatedOctave = clamp(modulatedOctave, -4, 4);
            // Note: This is real-time modulation - doesn't change the base octaveOffset
        } else if (paramId == PSEUDO_PARAM_PITCH) {
            // LFO modulates pitch in range -6 to +6 semitones
            float basePitch = pitchOffset.load();
            float modulatedPitch = basePitch + (lfoModulation * 6.0f);
            modulatedPitch = clamp(modulatedPitch, -12.0f, 12.0f);
            // Note: This is real-time modulation - doesn't change the base pitchOffset
        }

        lfo.lastUpdate = now;
    }
}

// Performance FX System Implementation
void GridSequencer::initializeEffect(PerformanceFX effect) {
    performanceFX.stepCounter = 0;
    performanceFX.loopPosition = 0;
    performanceFX.stutterCounter = 0;
    performanceFX.scratchPosition = 0;
    performanceFX.scratchDirection = true;

    switch (effect) {
        case PerformanceFX::LOOP_16:
            performanceFX.loopLength = 4;  // 16th note loop
            break;
        case PerformanceFX::LOOP_12:
            performanceFX.loopLength = 3;  // 12th note loop
            break;
        case PerformanceFX::LOOP_SHORT:
            performanceFX.loopLength = 2;  // 32nd note segments
            break;
        case PerformanceFX::LOOP_SHORTER:
            performanceFX.loopLength = 1;  // 48th note segments
            break;
        case PerformanceFX::RETRIGGER_PATTERN:
            // Backup current pattern and shuffle step order
            for (int row = 0; row < MAX_ENGINES; ++row) {
                for (int step = 0; step < 16; ++step) {
                    performanceFX.originalPattern[row][step] = enginePatterns[row][step];
                }
            }
            // Initialize shuffled order
            for (int i = 0; i < 16; ++i) {
                performanceFX.shuffledStepOrder[i] = i;
            }
            // Simple shuffle
            for (int i = 15; i > 0; --i) {
                int j = rand() % (i + 1);
                std::swap(performanceFX.shuffledStepOrder[i], performanceFX.shuffledStepOrder[j]);
            }
            break;
        case PerformanceFX::REVERSE:
            // Backup original pattern
            for (int row = 0; row < MAX_ENGINES; ++row) {
                for (int step = 0; step < 16; ++step) {
                    performanceFX.originalPattern[row][step] = enginePatterns[row][step];
                }
            }
            break;
        default:
            break;
    }
}

void GridSequencer::processPatternEffects() {
    if (!performanceFX.hasActiveEffects()) return;

    // Apply pattern manipulation effects from the active effects set
    for (auto effect : performanceFX.activeEffects) {
        switch (effect) {
            case PerformanceFX::RETRIGGER_PATTERN:
                // Apply shuffled step order
                if (performanceFX.stepCounter % 16 == 0) {  // Re-shuffle every 16 steps
                    for (int i = 15; i > 0; --i) {
                        int j = rand() % (i + 1);
                        std::swap(performanceFX.shuffledStepOrder[i], performanceFX.shuffledStepOrder[j]);
                    }
                }
                break;
            case PerformanceFX::REVERSE:
                // Reverse the pattern playback order (handled in sequencer step calculation)
                break;
            case PerformanceFX::QUANTIZE_6_8:
                // Modify timing to convert 4/4 to 6/8 feel
                // This would require tempo/timing changes in the sequencer
                break;
            default:
                break;
        }
    }

    performanceFX.stepCounter++;
}


void GridSequencer::deactivateEffect() {
    if (performanceFX.isEffectActive(PerformanceFX::RETRIGGER_PATTERN) || performanceFX.isEffectActive(PerformanceFX::REVERSE)) {
        // Restore original pattern
        for (int row = 0; row < MAX_ENGINES; ++row) {
            for (int step = 0; step < 16; ++step) {
                enginePatterns[row][step] = performanceFX.originalPattern[row][step];
            }
        }
    }

    performanceFX.clearAllEffects();
    std::cout << "🎵 Performance FX: DEACTIVATED" << std::endl;
}

// Bake Performance FX into permanent pattern
void bakePerformanceFXIntoPattern(PerformanceFX effect) {
    switch (effect) {
        case PerformanceFX::REVERSE:
            // Reverse the pattern for all engines
            for (int row = 0; row < MAX_ENGINES; ++row) {
                if (enginePatterns[row].size() >= 16) {
                    std::vector<StepData> reversed(16);
                    for (int step = 0; step < 16; ++step) {
                        reversed[step] = enginePatterns[row][15 - step];
                    }
                    for (int step = 0; step < 16; ++step) {
                        enginePatterns[row][step] = reversed[step];
                    }
                }
            }
            break;

        case PerformanceFX::RETRIGGER_PATTERN:
            // Apply shuffled pattern based on current shuffle state
            for (int row = 0; row < MAX_ENGINES; ++row) {
                if (enginePatterns[row].size() >= 16) {
                    std::vector<StepData> shuffled(16);
                    for (int step = 0; step < 16; ++step) {
                        int sourceStep = performanceFX.shuffledStepOrder[step];
                        if (sourceStep < static_cast<int>(enginePatterns[row].size())) {
                            shuffled[step] = enginePatterns[row][sourceStep];
                        }
                    }
                    for (int step = 0; step < 16; ++step) {
                        enginePatterns[row][step] = shuffled[step];
                    }
                }
            }
            break;

        case PerformanceFX::QUANTIZE_6_8:
            // Apply 6/8 quantization by moving steps to triplet positions
            for (int row = 0; row < MAX_ENGINES; ++row) {
                if (enginePatterns[row].size() >= 16) {
                    std::vector<StepData> quantized(16);
                    int sixEightPositions[] = {0, 2, 4, 6, 8, 10, 12, 14}; // Even steps for 6/8 feel
                    int sourceIdx = 0;

                    // Initialize with empty steps
                    for (int i = 0; i < 16; ++i) {
                        quantized[i] = StepData();
                    }

                    // Map active steps to 6/8 positions
                    for (int step = 0; step < 16; ++step) {
                        if (enginePatterns[row][step].active && sourceIdx < 8) {
                            quantized[sixEightPositions[sourceIdx]] = enginePatterns[row][step];
                            sourceIdx++;
                        }
                    }

                    for (int step = 0; step < 16; ++step) {
                        enginePatterns[row][step] = quantized[step];
                    }
                }
            }
            break;

        case PerformanceFX::LOOP_SHORT:
        case PerformanceFX::LOOP_SHORTER:
        case PerformanceFX::LOOP_12:
        case PerformanceFX::LOOP_16:
            // Repeat pattern segments to create loop-baked patterns
            {
                int loopLen = 4; // Default
                switch (effect) {
                    case PerformanceFX::LOOP_16: loopLen = 1; break;
                    case PerformanceFX::LOOP_12: loopLen = 2; break;
                    case PerformanceFX::LOOP_SHORT: loopLen = 4; break;
                    case PerformanceFX::LOOP_SHORTER: loopLen = 8; break;
                    default: break;
                }

                for (int row = 0; row < MAX_ENGINES; ++row) {
                    if (enginePatterns[row].size() >= 16) {
                        std::vector<StepData> looped(16);
                        for (int step = 0; step < 16; ++step) {
                            looped[step] = enginePatterns[row][step % loopLen];
                        }
                        for (int step = 0; step < 16; ++step) {
                            enginePatterns[row][step] = looped[step];
                        }
                    }
                }
            }
            break;

        case PerformanceFX::HALF_RATE:
            // Stretch pattern to half speed by doubling steps
            for (int row = 0; row < MAX_ENGINES; ++row) {
                if (enginePatterns[row].size() >= 16) {
                    std::vector<StepData> halfRate(16);
                    // Initialize with empty steps
                    for (int i = 0; i < 16; ++i) {
                        halfRate[i] = StepData();
                    }
                    for (int step = 0; step < 8; ++step) {
                        halfRate[step * 2] = enginePatterns[row][step];
                        // Skip odd steps (create gaps)
                    }
                    for (int step = 0; step < 16; ++step) {
                        enginePatterns[row][step] = halfRate[step];
                    }
                }
            }
            break;

        case PerformanceFX::BUILD_UP_16_BAR:
            // Create a build-up by gradually adding steps
            for (int row = 0; row < MAX_ENGINES; ++row) {
                if (enginePatterns[row].size() >= 16) {
                    std::vector<StepData> buildup(16);
                    int activeSteps = 0;

                    // Initialize with empty steps
                    for (int i = 0; i < 16; ++i) {
                        buildup[i] = StepData();
                    }

                    // Count active steps in original
                    for (int step = 0; step < 16; ++step) {
                        if (enginePatterns[row][step].active) activeSteps++;
                    }

                    // Add steps gradually (first quarter has fewer steps)
                    int stepsToAdd = std::max(1, activeSteps / 4);
                    int addedSteps = 0;
                    for (int step = 0; step < 16 && addedSteps < stepsToAdd; ++step) {
                        if (enginePatterns[row][step].active) {
                            buildup[step] = enginePatterns[row][step];
                            addedSteps++;
                        }
                    }

                    for (int step = 0; step < 16; ++step) {
                        enginePatterns[row][step] = buildup[step];
                    }
                }
            }
            break;

        default:
            // For other effects that don't modify patterns, do nothing
            break;
    }

    std::cout << "📝 Pattern permanently modified by " << PERFORMANCE_FX_NAMES[static_cast<int>(effect)] << std::endl;
}

void GridSequencer::showStatus() {
    std::cout << "\n=== EtherSynth Grid Sequencer ===" << std::endl;
    std::cout << "Grid: " << (gridConnected ? "Connected" : "Disconnected") << std::endl;
    const char* techName = currentInstrumentTypeName();
    const char* engineName = getDisplayName(techName);
    std::cout << "Current Engine Row: " << currentEngineRow << " (" << (engineName ? engineName : "Unknown") << ")" << std::endl;
    std::cout << "BPM: " << std::fixed << std::setprecision(1) << bpm.load();
    std::cout << " | " << (playing ? "PLAYING" : "STOPPED");
    if (playing) { std::cout << " | Step: " << (currentStep + 1) << "/16"; }
    std::cout << std::endl;
    std::cout << "Pattern [" << currentEngineRow << "]: ";
    for (int i = 0; i < 16; i++) { if (enginePatterns[currentEngineRow][i].active) { if (i == currentStep && playing) std::cout << "[" << (i+1) << "]"; else std::cout << " " << (i+1) << " "; } else { if (i == currentStep && playing) std::cout << "[·]"; else std::cout << " · "; } }
    std::cout << std::endl;
}

void GridSequencer::run() {
    enableRawMode(); setStdinNonblocking(); running = true; bool quit = false;
    while (running && !quit) {
        // Process encoder input and handle button timing
        processEncoderInput();
        updateButtonTimers();

        // Process LFOs for pseudo-parameters
        processPseudoParamLFOs();

        // Process Performance FX pattern effects
        processPatternEffects();

        usleep(1000); // 1ms delay like encoder_demo

        char c; while (read(STDIN_FILENO, &c, 1) == 1) {
        if (c == 'q') { quit = true; break; }
        if (c == ' ') { reqTogglePlay = true; }
        if (c == 'w' || c == 'W') { writeMode = !writeMode.load(); }
        if (c == 'c' || c == 'C') { reqClear = true; }
        if (c == 'a' || c == 'A') { playAllEngines = !playAllEngines.load(); }
        if (c == '[') { if (--selectedLFOIndex < 0) selectedLFOIndex = 0; }
        if (c == ']') { if (++selectedLFOIndex > 7) selectedLFOIndex = 7; }
        if (c == 'L') {
            showLFOAssign = !showLFOAssign;
            if (showLFOAssign && selectedParamIndex < (int)extendedVisibleParams.size()) {
                int activeMask = 0; float cur = 0.0f;
                int slot = rowToSlot[currentEngineRow]; if (slot < 0) slot = 0;
                int pid = getExtendedParameterId(selectedParamIndex);
                if (pid != -1 && pid != PSEUDO_PARAM_OCTAVE && pid != PSEUDO_PARAM_PITCH) {
                    ether_get_parameter_lfo_info(etherEngine, slot, pid, &activeMask, &cur);
                }
                lfoAssignMask = static_cast<uint32_t>(activeMask);
                lfoAssignCursor = 0;
            }
        }
        if (c == 'S') { showLFOSettings = !showLFOSettings; }
        if (c == 'T') { retriggerSettingsMode = !retriggerSettingsMode.load(); }
        if (c == 'A') { arpeggiatorSettingsMode = !arpeggiatorSettingsMode.load(); }
        if (c == 'G') { patternGateSettingsMode = !patternGateSettingsMode.load(); }
        if (c == 'v' || c == 'V') { int wf = (lfoWaveform[selectedLFOIndex] + 1) % 12; lfoWaveform[selectedLFOIndex] = wf; ether_set_lfo_waveform(etherEngine, (unsigned char)selectedLFOIndex, (unsigned char)wf); }
        if (c == 'r') { lfoRate[selectedLFOIndex] = std::max(0.01f, lfoRate[selectedLFOIndex] * 0.9f); ether_set_lfo_rate(etherEngine, (unsigned char)selectedLFOIndex, lfoRate[selectedLFOIndex]); }
        if (c == 'R') { lfoRate[selectedLFOIndex] = std::min(50.0f, lfoRate[selectedLFOIndex] * 1.1f); ether_set_lfo_rate(etherEngine, (unsigned char)selectedLFOIndex, lfoRate[selectedLFOIndex]); }
        if (c == 'd') { lfoDepth[selectedLFOIndex] = std::max(0.0f, lfoDepth[selectedLFOIndex] - 0.05f); ether_set_lfo_depth(etherEngine, (unsigned char)selectedLFOIndex, lfoDepth[selectedLFOIndex]); }
        if (c == 'D') { lfoDepth[selectedLFOIndex] = std::min(1.0f, lfoDepth[selectedLFOIndex] + 0.05f); ether_set_lfo_depth(etherEngine, (unsigned char)selectedLFOIndex, lfoDepth[selectedLFOIndex]); }
        
        // LFO assignment trigger (x/X/Enter when in LFO assign mode)
        if (showLFOAssign && (c == 'x' || c == 'X' || c == '\n')) {
            if (selectedParamIndex < (int)extendedVisibleParams.size()) {
                int pid = getExtendedParameterId(selectedParamIndex);
                if (pid == -1) continue;

                // Handle pseudo-parameters separately
                if (pid == PSEUDO_PARAM_OCTAVE || pid == PSEUDO_PARAM_PITCH) {
                    bool isAssigned = pseudoParamLFOs[pid].active && pseudoParamLFOs[pid].lfoIndex == lfoAssignCursor;
                    if (isAssigned) {
                        // Remove assignment
                        pseudoParamLFOs[pid].active = false;
                        pseudoParamLFOs[pid].lfoIndex = -1;
                        std::cout << "LFO #" << (lfoAssignCursor + 1) << " removed from pseudo-param "
                                  << (pid == PSEUDO_PARAM_OCTAVE ? "octave" : "pitch") << std::endl;
                    } else {
                        // Add assignment
                        pseudoParamLFOs[pid].active = true;
                        pseudoParamLFOs[pid].lfoIndex = lfoAssignCursor;
                        pseudoParamLFOs[pid].depth = 0.5f;
                        std::cout << "LFO #" << (lfoAssignCursor + 1) << " assigned to pseudo-param "
                                  << (pid == PSEUDO_PARAM_OCTAVE ? "octave" : "pitch") << std::endl;
                    }
                    continue;
                }
                int slot = rowToSlot[currentEngineRow]; if (slot < 0) slot = 0;
                bool on = ((lfoAssignMask >> lfoAssignCursor) & 1u) != 0;
                if (on) {
                    ether_remove_lfo_assignment_by_param(etherEngine, slot, lfoAssignCursor, pid);
                    lfoAssignMask &= ~(1u << lfoAssignCursor);
                } else {
                    ether_assign_lfo_to_param_id(etherEngine, slot, lfoAssignCursor, pid, lfoDepth[lfoAssignCursor]);
                    lfoAssignMask |= (1u << lfoAssignCursor);
                }
            }
        }
        
        // Unified menu navigation - vim keys and arrows
        if (c == 'j') {
            if (showLFOAssign) {
                lfoAssignCursor = std::min(7, lfoAssignCursor + 1);
            } else if (retriggerSettingsMode.load()) {
                retriggerSettingsIndex = std::min(5, retriggerSettingsIndex + 1);
            } else if (arpeggiatorSettingsMode.load()) {
                arpeggiatorSettingsIndex = std::min(5, arpeggiatorSettingsIndex + 1);
            } else if (patternGateSettingsMode.load()) {
                patternGateSettingsIndex = std::min(4, patternGateSettingsIndex + 1);
            } else {
                int maxIdx = (int)extendedVisibleParams.size() + extraMenuRows();
                int idx = selectedParamIndex + 1; if (idx > maxIdx) idx = maxIdx; selectedParamIndex = idx;
            }
        } else if (c == 'k') {
            if (showLFOAssign) {
                lfoAssignCursor = std::max(0, lfoAssignCursor - 1);
            } else if (retriggerSettingsMode.load()) {
                retriggerSettingsIndex = std::max(0, retriggerSettingsIndex - 1);
            } else if (arpeggiatorSettingsMode.load()) {
                arpeggiatorSettingsIndex = std::max(0, arpeggiatorSettingsIndex - 1);
            } else if (patternGateSettingsMode.load()) {
                patternGateSettingsIndex = std::max(0, patternGateSettingsIndex - 1);
            } else {
                int maxIdx = (int)extendedVisibleParams.size() + extraMenuRows();
                int idx = selectedParamIndex - 1; if (idx < 0) idx = 0; selectedParamIndex = idx;
            }
        } else if (c == '\x1b') { // ESC sequence for arrow keys
            char seq[2];
            if (read(STDIN_FILENO, &seq[0], 1) != 1) continue;
            if (read(STDIN_FILENO, &seq[1], 1) != 1) continue;
            if (seq[0] == '[') {
                if (seq[1] == 'A') { // Up - unified menu navigation
                    if (showLFOAssign) {
                        lfoAssignCursor = std::max(0, lfoAssignCursor - 1);
                    } else if (retriggerSettingsMode.load()) {
                        retriggerSettingsIndex = std::max(0, retriggerSettingsIndex - 1);
                    } else {
                        int maxIdx = (int)extendedVisibleParams.size() + extraMenuRows();
                        int idx = selectedParamIndex - 1; if (idx < 0) idx = 0; selectedParamIndex = idx;
                    }
                } else if (seq[1] == 'B') { // Down - unified menu navigation
                    if (showLFOAssign) {
                        lfoAssignCursor = std::min(7, lfoAssignCursor + 1);
                    } else if (retriggerSettingsMode.load()) {
                        retriggerSettingsIndex = std::min(5, retriggerSettingsIndex + 1);
                    } else if (patternGateSettingsMode.load()) {
                        patternGateSettingsIndex = std::min(4, patternGateSettingsIndex + 1);
                    } else {
                        int maxIdx = (int)extendedVisibleParams.size() + extraMenuRows();
                        int idx = selectedParamIndex + 1; if (idx > maxIdx) idx = maxIdx; selectedParamIndex = idx;
                    }
                } else if (seq[1] == 'C') { // Right - parameter adjustment
                    if (showLFOAssign) {
                        lfoAssignCursor = std::min(7, lfoAssignCursor + 1);
                    } else if (retriggerSettingsMode.load()) {
                        if (retriggerSettingsIndex == 0) {
                            retriggerSettings.numTriggers = std::min(8, retriggerSettings.numTriggers + 1);
                        } else if (retriggerSettingsIndex == 1) {
                            retriggerSettings.stepWindow = std::min(4, retriggerSettings.stepWindow + 1);
                        } else if (retriggerSettingsIndex == 2) {
                            retriggerSettings.octaveShift = std::min(2, retriggerSettings.octaveShift + 1);
                        } else if (retriggerSettingsIndex == 3) {
                            retriggerSettings.timingMode = static_cast<RetriggerTimingMode>(std::min(4, static_cast<int>(retriggerSettings.timingMode) + 1));
                        } else if (retriggerSettingsIndex == 4) {
                            retriggerSettings.velocityMode = static_cast<RetriggerVelocityMode>(std::min(4, static_cast<int>(retriggerSettings.velocityMode) + 1));
                        } else if (retriggerSettingsIndex == 5) {
                            retriggerSettings.intensityCurve = std::min(1.0f, retriggerSettings.intensityCurve + 0.1f);
                        }
                    } else if (arpeggiatorSettingsMode.load()) {
                        if (arpeggiatorSettingsIndex == 0) {
                            arpeggiatorSettings.pattern = static_cast<ArpPattern>(std::min(6, static_cast<int>(arpeggiatorSettings.pattern) + 1));
                        } else if (arpeggiatorSettingsIndex == 1) {
                            arpeggiatorSettings.length = std::min(8, arpeggiatorSettings.length + 1);
                        } else if (arpeggiatorSettingsIndex == 2) {
                            if (arpeggiatorSettings.cycles == -1) arpeggiatorSettings.cycles = 1;
                            else arpeggiatorSettings.cycles = std::min(16, arpeggiatorSettings.cycles + 1);
                        } else if (arpeggiatorSettingsIndex == 3) {
                            arpeggiatorSettings.octaveRange = std::min(4, arpeggiatorSettings.octaveRange + 1);
                        } else if (arpeggiatorSettingsIndex == 4) {
                            if (arpeggiatorSettings.speed == 1) arpeggiatorSettings.speed = 2;
                            else if (arpeggiatorSettings.speed == 2) arpeggiatorSettings.speed = 4;
                            else if (arpeggiatorSettings.speed == 4) arpeggiatorSettings.speed = 8;
                            else if (arpeggiatorSettings.speed == 8) arpeggiatorSettings.speed = 16;
                        } else if (arpeggiatorSettingsIndex == 5) {
                            arpeggiatorSettings.gateLength = std::min(100, arpeggiatorSettings.gateLength + 5);
                        }
                    } else if (patternGateSettingsMode.load()) {
                        if (patternGateSettingsIndex == 0) {
                            patternGateSettings.mode = static_cast<PatternGateMode>(std::min(2, static_cast<int>(patternGateSettings.mode) + 1));
                        } else if (patternGateSettingsIndex == 1) {
                            // Cycle through common patterns: alternating, quarter notes, eighth triplets, etc.
                            uint16_t patterns[] = {0b1010101010101010, 0b1000100010001000, 0b1100110011001100, 0b1111000011110000, 0b1110111011101110};
                            int currentIdx = 0;
                            for (int i = 0; i < 5; i++) {
                                if (patternGateSettings.pattern == patterns[i]) { currentIdx = i; break; }
                            }
                            patternGateSettings.pattern = patterns[(currentIdx + 1) % 5];
                        } else if (patternGateSettingsIndex == 2) {
                            patternGateSettings.probability = std::min(1.0f, patternGateSettings.probability + 0.05f);
                        } else if (patternGateSettingsIndex == 3) {
                            if (patternGateSettings.resolution == 1) patternGateSettings.resolution = 2;
                            else if (patternGateSettings.resolution == 2) patternGateSettings.resolution = 4;
                            else if (patternGateSettings.resolution == 4) patternGateSettings.resolution = 8;
                            else if (patternGateSettings.resolution == 8) patternGateSettings.resolution = 16;
                        } else if (patternGateSettingsIndex == 4) {
                            patternGateSettings.swing = std::min(0.5f, patternGateSettings.swing + 0.1f);
                        }
                    } else if (selectedParamIndex < (int)extendedVisibleParams.size()) {
                        int pid = getExtendedParameterId(selectedParamIndex);
                        if (pid == PSEUDO_PARAM_OCTAVE) {
                            octaveOffset = std::min(4, octaveOffset.load() + 1);
                        } else if (pid == PSEUDO_PARAM_PITCH) {
                            pitchOffset = std::min(12.0f, pitchOffset.load() + 0.5f);
                        } else if (pid != -1) {
                            adjustParameter(pid, true); // Clean increment call
                        }
                    } else {
                        // FX section adjustment (voices, sends, global FX)
                        int base = (int)extendedVisibleParams.size();
                        if (selectedParamIndex == base) {
                            int slot = rowToSlot[currentEngineRow]; if (slot < 0) slot = 0;
                            int voices = ether_get_engine_voice_count(etherEngine, slot);
                            voices = std::min(16, voices + 1);
                            ether_set_engine_voice_count(etherEngine, slot, voices);
                        } else if (selectedParamIndex == base+1) {
                            float v = std::min(1.0f, ether_get_engine_fx_send(etherEngine, currentEngineRow, 0) + 0.02f);
                            ether_set_engine_fx_send(etherEngine, currentEngineRow, 0, v);
                        } else if (selectedParamIndex == base+2) {
                            float v = std::min(1.0f, ether_get_engine_fx_send(etherEngine, currentEngineRow, 1) + 0.02f);
                            ether_set_engine_fx_send(etherEngine, currentEngineRow, 1, v);
                        } else if (selectedParamIndex >= base+3 && selectedParamIndex <= base+8) {
                            int which = (selectedParamIndex<=base+5)?0:1;
                            int param = (selectedParamIndex-(base+3)) % 3;
                            float cur = ether_get_fx_global(etherEngine, which, param);
                            ether_set_fx_global(etherEngine, which, param, std::min(1.0f, cur+0.02f));
                        }
                    }
                } else if (seq[1] == 'D') { // Left - parameter adjustment
                    if (showLFOAssign) {
                        lfoAssignCursor = std::max(0, lfoAssignCursor - 1);
                    } else if (retriggerSettingsMode.load()) {
                        if (retriggerSettingsIndex == 0) {
                            retriggerSettings.numTriggers = std::max(1, retriggerSettings.numTriggers - 1);
                        } else if (retriggerSettingsIndex == 1) {
                            retriggerSettings.stepWindow = std::max(1, retriggerSettings.stepWindow - 1);
                        } else if (retriggerSettingsIndex == 2) {
                            retriggerSettings.octaveShift = std::max(-2, retriggerSettings.octaveShift - 1);
                        } else if (retriggerSettingsIndex == 3) {
                            retriggerSettings.timingMode = static_cast<RetriggerTimingMode>(std::max(0, static_cast<int>(retriggerSettings.timingMode) - 1));
                        } else if (retriggerSettingsIndex == 4) {
                            retriggerSettings.velocityMode = static_cast<RetriggerVelocityMode>(std::max(0, static_cast<int>(retriggerSettings.velocityMode) - 1));
                        } else if (retriggerSettingsIndex == 5) {
                            retriggerSettings.intensityCurve = std::max(0.0f, retriggerSettings.intensityCurve - 0.1f);
                        }
                    } else if (arpeggiatorSettingsMode.load()) {
                        if (arpeggiatorSettingsIndex == 0) {
                            arpeggiatorSettings.pattern = static_cast<ArpPattern>(std::max(0, static_cast<int>(arpeggiatorSettings.pattern) - 1));
                        } else if (arpeggiatorSettingsIndex == 1) {
                            arpeggiatorSettings.length = std::max(1, arpeggiatorSettings.length - 1);
                        } else if (arpeggiatorSettingsIndex == 2) {
                            if (arpeggiatorSettings.cycles == 1) arpeggiatorSettings.cycles = -1;
                            else arpeggiatorSettings.cycles = std::max(1, arpeggiatorSettings.cycles - 1);
                        } else if (arpeggiatorSettingsIndex == 3) {
                            arpeggiatorSettings.octaveRange = std::max(1, arpeggiatorSettings.octaveRange - 1);
                        } else if (arpeggiatorSettingsIndex == 4) {
                            if (arpeggiatorSettings.speed == 16) arpeggiatorSettings.speed = 8;
                            else if (arpeggiatorSettings.speed == 8) arpeggiatorSettings.speed = 4;
                            else if (arpeggiatorSettings.speed == 4) arpeggiatorSettings.speed = 2;
                            else if (arpeggiatorSettings.speed == 2) arpeggiatorSettings.speed = 1;
                        } else if (arpeggiatorSettingsIndex == 5) {
                            arpeggiatorSettings.gateLength = std::max(25, arpeggiatorSettings.gateLength - 5);
                        }
                    } else if (patternGateSettingsMode.load()) {
                        if (patternGateSettingsIndex == 0) {
                            patternGateSettings.mode = static_cast<PatternGateMode>(std::max(0, static_cast<int>(patternGateSettings.mode) - 1));
                        } else if (patternGateSettingsIndex == 1) {
                            // Cycle through common patterns in reverse
                            uint16_t patterns[] = {0b1010101010101010, 0b1000100010001000, 0b1100110011001100, 0b1111000011110000, 0b1110111011101110};
                            int currentIdx = 4;  // Default to last
                            for (int i = 0; i < 5; i++) {
                                if (patternGateSettings.pattern == patterns[i]) { currentIdx = i; break; }
                            }
                            patternGateSettings.pattern = patterns[(currentIdx + 4) % 5]; // +4 is same as -1 mod 5
                        } else if (patternGateSettingsIndex == 2) {
                            patternGateSettings.probability = std::max(0.0f, patternGateSettings.probability - 0.05f);
                        } else if (patternGateSettingsIndex == 3) {
                            if (patternGateSettings.resolution == 16) patternGateSettings.resolution = 8;
                            else if (patternGateSettings.resolution == 8) patternGateSettings.resolution = 4;
                            else if (patternGateSettings.resolution == 4) patternGateSettings.resolution = 2;
                            else if (patternGateSettings.resolution == 2) patternGateSettings.resolution = 1;
                        } else if (patternGateSettingsIndex == 4) {
                            patternGateSettings.swing = std::max(-0.5f, patternGateSettings.swing - 0.1f);
                        }
                    } else if (selectedParamIndex < (int)extendedVisibleParams.size()) {
                        int pid = getExtendedParameterId(selectedParamIndex);
                        if (pid == PSEUDO_PARAM_OCTAVE) {
                            octaveOffset = std::max(-4, octaveOffset.load() - 1);
                        } else if (pid == PSEUDO_PARAM_PITCH) {
                            pitchOffset = std::max(-12.0f, pitchOffset.load() - 0.5f);
                        } else if (pid != -1) {
                            adjustParameter(pid, false); // Clean decrement call
                        }
                    } else {
                        // FX section adjustment (voices, sends, global FX)
                        int base = (int)extendedVisibleParams.size();
                        if (selectedParamIndex == base) {
                            int slot = rowToSlot[currentEngineRow]; if (slot < 0) slot = 0;
                            int voices = ether_get_engine_voice_count(etherEngine, slot);
                            voices = std::max(1, voices - 1);
                            ether_set_engine_voice_count(etherEngine, slot, voices);
                        } else if (selectedParamIndex == base+1) {
                            float v = std::max(0.0f, ether_get_engine_fx_send(etherEngine, currentEngineRow, 0) - 0.02f);
                            ether_set_engine_fx_send(etherEngine, currentEngineRow, 0, v);
                        } else if (selectedParamIndex == base+2) {
                            float v = std::max(0.0f, ether_get_engine_fx_send(etherEngine, currentEngineRow, 1) - 0.02f);
                            ether_set_engine_fx_send(etherEngine, currentEngineRow, 1, v);
                        } else if (selectedParamIndex >= base+3 && selectedParamIndex <= base+8) {
                            int which = (selectedParamIndex<=base+5)?0:1;
                            int param = (selectedParamIndex-(base+3)) % 3;
                            float cur = ether_get_fx_global(etherEngine, which, param);
                            ether_set_fx_global(etherEngine, which, param, std::max(0.0f, cur-0.02f));
                        }
                    }
                }
            }
        }
    } drawFixedUI(); std::this_thread::sleep_for(std::chrono::milliseconds(50)); }
    disableRawMode(); std::cout << "\nGoodbye!" << std::endl;
}

void GridSequencer::play() {
    if (!playing) {
        std::cout << "[DEBUG] CORRECT GridSequencer::play() called - setting playing=true, currentStep=0" << std::endl;
        // Log to file for crash analysis
        std::ofstream logFile("grid_sequencer_debug.log", std::ios::app);
        if (logFile.is_open()) {
            logFile << "[" << std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count() << "] Starting play() - setting playing=true, currentStep=0" << std::endl;
            logFile.close();
        }
        playing = true;
        currentStep = 0;

        // Advanced grid controller: reset write mode when starting playback
        // Write mode defaults to OFF when playing (requires hold to activate)
        writeMode = false;
        std::cout << "Write mode reset to OFF (playing mode)" << std::endl;

        std::cout << "✓ Playing all engines" << std::endl;
        
        std::cout << "[DEBUG] Creating sequencer thread..." << std::endl;
        sequencerThread = std::thread([this]() {
            std::cout << "[DEBUG] Sequencer thread started, entering loop" << std::endl;
            while (playing) {
                if (isCurrentEngineDrum()) {
                    // Trigger any drum whose bit at currentStep is set; let engine manage decay
                    int slot = rowToSlot[currentEngineRow]; if (slot < 0) slot = 0;
                    if (!(soloEngine>=0 && currentEngineRow!=soloEngine) && !rowMuted[currentEngineRow]) {
                        ether_set_active_instrument(etherEngine, slot);
                        bool chNow = ((drumMasks[8] >> currentStep) & 1u) || ((drumMasks[9] >> currentStep) & 1u);
                        for (int pad = 0; pad < 16; ++pad) {
                            if ((drumMasks[pad] >> currentStep) & 1u) {
                                // Skip if we just previewed this pad at this step
                                int prev = drumPreviewStep[pad].load();
                                if (prev == currentStep) { drumPreviewStep[pad] = -1; continue; }
                                if (chNow && pad == 10) continue; // choke OH when CH/PH hit same step
                                float vel = accentLatch ? 1.0f : 0.9f;
                                ether_note_on(etherEngine, DRUM_PAD_NOTES[pad], vel, 0.0f);
                            }
                        }
                    }
                } else {
                    if (playAllEngines) {
                        // Trigger all rows (drums + melodic)
                        for (int s = 0; s < 16; ++s) {
                            int row = slotToRow[s]; if (row < 0) continue;
                            if (soloEngine >= 0 && row != soloEngine) continue;
                            if (rowMuted[row]) continue;
                            
                            int slot = rowToSlot[row]; if (slot < 0) slot = 0;
                            ether_set_active_instrument(etherEngine, slot);
                            bool isDrum = isEngineDrum(row);
                            
                            if (isDrum) {
                                bool chNow = ((drumMasks[8] >> currentStep) & 1u) || ((drumMasks[9] >> currentStep) & 1u);
                                for (int pad = 0; pad < 16; ++pad) {
                                    if ((drumMasks[pad] >> currentStep) & 1u) {
                                        // Skip if we just previewed this pad at this step
                                        int prev = drumPreviewStep[pad].load();
                                        if (prev == currentStep) { drumPreviewStep[pad] = -1; continue; }
                                        if (chNow && pad == 10) continue; // choke OH when CH/PH hit same step
                                        float vel = accentLatch ? 1.0f : 0.9f;
                                        ether_note_on(etherEngine, DRUM_PAD_NOTES[pad], vel, 0.0f);
                                    }
                                }
                            } else {
                                if (enginePatterns[row][currentStep].active) {
                                    // Skip if just previewed live in this step
                                    int prev = melodicPreviewStep[row].load();
                                    if (prev == currentStep) { melodicPreviewStep[row] = -1; }
                                    else { stepTrigger[row][currentStep] = true; }
                                }
                            }
                        }
                        // Schedule melodic note offs only (drums manage decay)
                        std::thread([this]() {
                            float stepMs = (60.0f / bpm) / 4.0f * 1000.0f;
                            for (int s = 0; s < 16; ++s) {
                                int row = slotToRow[s]; if (row < 0) continue;
                                if (soloEngine >= 0 && row != soloEngine) continue;
                                if (rowMuted[row]) continue;
                                
                                int slot = rowToSlot[row]; if (slot < 0) slot = 0;
                                bool isDrum = isEngineDrum(row);
                                if (!isDrum) {
                                    float releaseParam = engineParameters[row][static_cast<int>(ParameterID::RELEASE)];
                                    float noteOffMs = stepMs * (0.1f + releaseParam * 0.8f);
                                    std::this_thread::sleep_for(std::chrono::milliseconds(static_cast<int>(noteOffMs)));
                                    if (playing) {
                                        noteOffTrigger[row][currentStep] = true;
                                    }
                                }
                            }
                        }).detach();
                    } else {
                        int engine = currentEngineRow;
                        if (soloEngine >= 0 && engine != soloEngine) {
                            // skip
                        } else if (!rowMuted[engine] && enginePatterns[engine][currentStep].active) {
                            stepTrigger[engine][currentStep] = true;
                            std::thread([this, engine]() {
                                float stepMs = (60.0f / bpm) / 4.0f * 1000.0f;
                                float releaseParam = engineParameters[engine][static_cast<int>(ParameterID::RELEASE)];
                                float noteOffMs = stepMs * (0.1f + releaseParam * 0.8f);
                                std::this_thread::sleep_for(std::chrono::milliseconds(static_cast<int>(noteOffMs)));
                                if (playing) {
                                    noteOffTrigger[engine][currentStep] = true;
                                }
                            }).detach();
                        }
                    }
                }
                
                currentStep = getNextStep(currentStep);

                // Check if any double-speed effects are active to adjust timing
                bool doubleSpeedActive = false;
                for (const auto& effect : performanceFX.activeEffects) {
                    if (effect == PerformanceFX::LOOP_16_DOUBLE ||
                        effect == PerformanceFX::LOOP_12_DOUBLE ||
                        effect == PerformanceFX::LOOP_SHORT_DOUBLE ||
                        effect == PerformanceFX::LOOP_SHORTER_DOUBLE) {
                        doubleSpeedActive = true;
                        break;
                    }
                }

                float stepMs = (60.0f / bpm) / 4.0f * 1000.0f;
                if (doubleSpeedActive) {
                    stepMs /= 2.0f; // Double speed = half the time
                }
                std::this_thread::sleep_for(std::chrono::milliseconds(static_cast<int>(stepMs)));
            }
            std::cout << "[DEBUG] Sequencer thread exiting loop" << std::endl;
        });
        std::cout << "[DEBUG] play() complete - thread started" << std::endl;
    }
}

void GridSequencer::stop() {
    if (playing) { 
        std::cout << "[DEBUG] Starting stop() - setting playing=false" << std::endl;
        playing = false; 
        std::cout << "[DEBUG] Calling ether_all_notes_off" << std::endl;
        ether_all_notes_off(etherEngine); 
        std::cout << "[DEBUG] Checking if sequencer thread is joinable..." << std::endl;
        if (sequencerThread.joinable()) {
            std::cout << "[DEBUG] Joining sequencer thread..." << std::endl;
            sequencerThread.join();
            std::cout << "[DEBUG] Sequencer thread joined successfully" << std::endl;
        }
        std::cout << "✓ Stopped" << std::endl; 
    }
}

void GridSequencer::clearPattern() {
    if (isCurrentEngineDrum()) { for (auto &m : drumMasks) m = 0; } else { for (auto& step : enginePatterns[currentEngineRow]) step.active = false; } const char* techName = currentInstrumentTypeName(); const char* name = getDisplayName(techName); std::cout << "✓ Cleared pattern for " << (name ? name : "Unknown") << std::endl;
}

void GridSequencer::shutdownSequencer() {
    if (running) { stop(); running = false; if (sequencerThread.joinable()) sequencerThread.join(); if (ledUpdateThread.joinable()) ledUpdateThread.join(); if (grid_server) { lo_server_thread_stop(grid_server); lo_server_thread_free(grid_server); grid_server = nullptr; } if (grid_addr) { lo_address_free(grid_addr); grid_addr = nullptr; } if (stream) { Pa_CloseStream(stream); stream = nullptr; } Pa_Terminate(); if (etherEngine) { ether_shutdown(etherEngine); ether_destroy(etherEngine); etherEngine = nullptr; } audioRunning = false; }
}

/* END_OLD_INCLASS */

// Encoder control system implementation
void GridSequencer::setupEncoderSystem() {
    // Simple encoder setup - just connect to serial like encoder_demo
    std::cout << "Waiting for encoder controller..." << std::endl;
    sleep(2);  // Give QTPY time to boot and run script

    std::vector<std::string> devices = {"/dev/tty.usbmodem101", "/dev/tty.usbmodemm59111127381"};
    for (const auto& device : devices) {
        std::cout << "Trying to connect to: " << device << std::endl;
        if (encoderSerial.open(device)) {
            std::cout << "📡 Connected to encoder controller: " << device << std::endl;
            break;
        }
    }
}

void GridSequencer::updateEngineFromEncoderChange(const std::string& param_id, float delta) {
    // Parse param_id like "engine2_cutoff"
    size_t underscore = param_id.find('_');
    if (underscore == std::string::npos) return;

    std::string engine_part = param_id.substr(0, underscore);
    std::string param_part = param_id.substr(underscore + 1);

    if (engine_part.substr(0, 6) != "engine") return;

    int engine_num = std::stoi(engine_part.substr(6));
    if (engine_num < 0 || engine_num >= MAX_ENGINES) return;

    // Map parameter name to ParameterID
    ParameterID pid;
    if (param_part == "cutoff") pid = ParameterID::FILTER_CUTOFF;
    else if (param_part == "resonance") pid = ParameterID::FILTER_RESONANCE;
    else if (param_part == "attack") pid = ParameterID::ATTACK;
    else if (param_part == "decay") pid = ParameterID::DECAY;
    else if (param_part == "sustain") pid = ParameterID::SUSTAIN;
    else if (param_part == "release") pid = ParameterID::RELEASE;
    else if (param_part == "volume") pid = ParameterID::VOLUME;
    else if (param_part == "pan") pid = ParameterID::PAN;
    else if (param_part == "reverb") pid = ParameterID::REVERB_MIX;
    else return;

    // Update the actual synthesizer engine
    int slot = rowToSlot[engine_num];
    if (slot < 0) slot = 0;

    // Get current value, add delta, and clamp
    float current_value = engineParameters[engine_num][static_cast<int>(pid)];
    float new_value = clamp(current_value + delta, 0.0f, 1.0f);

    // Update both our local copy and the engine
    engineParameters[engine_num][static_cast<int>(pid)] = new_value;
    ether_set_instrument_parameter(etherEngine, slot, static_cast<int>(pid), new_value);
}

std::string getParameterName(ParameterID pid) {
    switch (pid) {
        case ParameterID::HARMONICS: return "harmonics";
        case ParameterID::TIMBRE: return "timbre";
        case ParameterID::MORPH: return "morph";
        case ParameterID::ATTACK: return "attack";
        case ParameterID::DECAY: return "decay";
        case ParameterID::SUSTAIN: return "sustain";
        case ParameterID::RELEASE: return "release";
        case ParameterID::FILTER_CUTOFF: return "lpf";
        case ParameterID::FILTER_RESONANCE: return "resonance";
        case ParameterID::HPF: return "hpf";
        case ParameterID::VOLUME: return "volume";
        case ParameterID::PAN: return "pan";
        case ParameterID::REVERB_MIX: return "reverb";
        default: return "unknown";
    }
}

void GridSequencer::syncMenuWithEncoder(const std::string& param_id) {
    // Instead of using encoder's own menu system, directly control the grid sequencer's selectedParamIndex
    // This makes encoder navigation work exactly like arrow keys

    // We don't need to parse param_id - just move the cursor directly
    // The encoder control system will call this when it wants to move the cursor
}

void GridSequencer::handleEncoderLatch(int encoder_id) {
    if (encoder_id < 1 || encoder_id > 3) return;

    int enc_index = encoder_id - 1;

    // Latch to currently selected parameter
    if (selectedParamIndex >= 0 && selectedParamIndex < (int)extendedVisibleParams.size()) {
        encoderLatches[enc_index].active = true;
        encoderLatches[enc_index].paramIndex = selectedParamIndex;
        int pid = getExtendedParameterId(selectedParamIndex);
        if (pid != -1) {
            encoderLatches[enc_index].paramName = parameterNames[pid];
        } else {
            encoderLatches[enc_index].paramName = "Unknown";
        }

        std::cout << "🔒 Encoder " << encoder_id << " latched to " << encoderLatches[enc_index].paramName << std::endl;
    }
}

void GridSequencer::adjustLatchedParameter(int enc_index, int delta) {
    if (!encoderLatches[enc_index].active) return;
    if (encoderLatches[enc_index].paramIndex < 0 || encoderLatches[enc_index].paramIndex >= (int)extendedVisibleParams.size()) return;

    int pid = getExtendedParameterId(encoderLatches[enc_index].paramIndex);

    if (pid == PSEUDO_PARAM_OCTAVE) {
        octaveOffset = clamp(octaveOffset.load() + delta, -4, 4);
        std::cout << "🎛️ Octave: " << (octaveOffset.load() > 0 ? "+" : "") << octaveOffset.load() << std::endl;
    } else if (pid == PSEUDO_PARAM_PITCH) {
        pitchOffset = clamp(pitchOffset.load() + (delta * 0.1f), -12.0f, 12.0f);
        std::cout << "🎛️ Pitch: " << (pitchOffset.load() > 0 ? "+" : "") << std::fixed << std::setprecision(1) << pitchOffset.load() << " st" << std::endl;
    } else if (pid != -1) {
        int slot = rowToSlot[currentEngineRow];
        if (slot < 0) slot = 0;

        // Get current parameter value
        float currentValue = ether_get_instrument_parameter(etherEngine, slot, pid);

        // Adjust by small increments (0.01 per encoder step)
        float newValue = currentValue + (delta * 0.01f);
        newValue = std::max(0.0f, std::min(1.0f, newValue));  // Clamp to 0-1

        // Set the new value
        ether_set_instrument_parameter(etherEngine, slot, pid, newValue);
        std::cout << "🎛️ " << encoderLatches[enc_index].paramName << ": " << std::fixed << std::setprecision(2) << newValue << std::endl;
    }
}

void GridSequencer::processEncoderInput() {
    // Read serial data - replicate encoder_demo approach exactly
    char buffer[256];
    int bytesRead = encoderSerial.readData(buffer, sizeof(buffer) - 1);
    if (bytesRead > 0) {
        buffer[bytesRead] = '\0';
        serialLineBuffer += buffer;

        // Process complete lines
        size_t pos;
        while ((pos = serialLineBuffer.find('\n')) != std::string::npos) {
            std::string line = serialLineBuffer.substr(0, pos);
            serialLineBuffer = serialLineBuffer.substr(pos + 1);

            if (!line.empty() && line.back() == '\r') {
                line.pop_back();
            }

            // Parse encoder commands - direct approach like encoder_demo
            if (!line.empty() && line[0] == 'E') {
                // Format: E1:+1 or E2:-1
                if (line.size() >= 4 && line[2] == ':') {
                    int encoder_id = line[1] - '0';
                    int delta = std::stoi(line.substr(3));
                    std::cout << "🎛️ Encoder " << encoder_id << " turned " << delta << std::endl;

                    // Handle encoder directly like encoder_demo
                    if (encoder_id == 4) {
                        // Encoder 4: Menu navigation
                        handleEncoder4Turn(delta);
                    } else {
                        // Encoders 1-3: Parameter control (for now, adjust current param)
                        handleParameterEncoderTurn(encoder_id, delta);
                    }
                }
            } else if (!line.empty() && line[0] == 'B') {
                // Format: B1:PRESS or B1:RELEASE
                if (line.size() >= 4 && line[2] == ':') {
                    int encoder_id = line[1] - '0';
                    std::string action = line.substr(3);
                    if (action == "PRESS") {
                        std::cout << "🔘 Button " << encoder_id << " PRESSED" << std::endl;
                        handleEncoderButtonPress(encoder_id);
                    } else if (action == "RELEASE") {
                        std::cout << "🔘 Button " << encoder_id << " RELEASED" << std::endl;
                    }
                }
            }
        }
    }
}

// Proper control architecture implementation
void GridSequencer::handleEncoder4Turn(int delta) {
    // Check if PATTERN button is held - if so, handle pattern bank pagination
    if (patternHold.load()) {
        // PATTERN + Encoder 4: Pattern bank pagination
        int oldBank = currentPatternBank.load();
        currentPatternBank = clamp(currentPatternBank.load() + delta, 0, 3);

        if (currentPatternBank.load() != oldBank) {
            // Pattern bank updated - status shown in terminal GUI
        }
        return;
    }

    if (editMode) {
        // Edit mode: adjust currently selected parameter
        std::cout << ">>> EDIT MODE: Adjusting parameter " << (delta > 0 ? "UP" : "DOWN") << std::endl;

        if (selectedParamIndex >= 0 && selectedParamIndex < (int)extendedVisibleParams.size()) {
            int pid = getExtendedParameterId(selectedParamIndex);
            if (pid != -1) {
                // Handle pseudo-parameters
                if (pid == PSEUDO_PARAM_OCTAVE) {
                    octaveOffset = clamp(octaveOffset.load() + delta, -4, 4);
                    std::cout << "Encoder adjusted octave to: " << octaveOffset.load() << std::endl;
                    return;
                } else if (pid == PSEUDO_PARAM_PITCH) {
                    pitchOffset = clamp(pitchOffset.load() + (delta * 0.1f), -12.0f, 12.0f);
                    std::cout << "Encoder adjusted pitch to: " << pitchOffset.load() << std::endl;
                    return;
                }

                float current_value = engineParameters[currentEngineRow][pid];
                float new_value = clamp(current_value + (delta * 0.01f), 0.0f, 1.0f);
                engineParameters[currentEngineRow][pid] = new_value;
                int slot = rowToSlot[currentEngineRow];
                if (slot < 0) slot = 0;
                ether_set_instrument_parameter(etherEngine, slot, pid, new_value);

                std::cout << ">>> PARAM UPDATE: " << parameterNames[pid] << " = " << new_value << std::endl;
            }
        }
    } else {
        // Browse mode: navigate menu
        std::cout << ">>> MENU NAVIGATION: " << (delta > 0 ? "DOWN" : "UP") << std::endl;

        int maxIdx = (int)extendedVisibleParams.size() + extraMenuRows();
        if (delta > 0) {
            selectedParamIndex = std::min(maxIdx, selectedParamIndex + 1);
        } else {
            selectedParamIndex = std::max(0, selectedParamIndex - 1);
        }
    }
}

void GridSequencer::handleParameterEncoderTurn(int encoder_id, int delta) {
    int enc_index = encoder_id - 1; // Convert to 0-2 index
    std::cout << ">>> ENCODER " << encoder_id << " TURN: " << (delta > 0 ? "CW" : "CCW") << std::endl;

    if (paramLatches[enc_index].active) {
        // Adjust latched parameter on the specific engine it was latched to
        ParameterID pid = paramLatches[enc_index].paramId;
        int latchedEngineRow = paramLatches[enc_index].engineRow;

        // Handle pseudo-parameters specially
        if (static_cast<int>(pid) == PSEUDO_PARAM_OCTAVE) {
            octaveOffset = clamp(octaveOffset.load() + delta, -4, 4);
            std::cout << ">>> LATCHED PSEUDO-PARAM: octave = " << octaveOffset.load() << std::endl;
        } else if (static_cast<int>(pid) == PSEUDO_PARAM_PITCH) {
            pitchOffset = clamp(pitchOffset.load() + (delta * 0.1f), -12.0f, 12.0f);
            std::cout << ">>> LATCHED PSEUDO-PARAM: pitch = " << pitchOffset.load() << std::endl;
        } else {
            // Handle real parameters
            float current_value = engineParameters[latchedEngineRow][static_cast<int>(pid)];
            float new_value = clamp(current_value + (delta * 0.01f), 0.0f, 1.0f);
            engineParameters[latchedEngineRow][static_cast<int>(pid)] = new_value;

            int slot = rowToSlot[latchedEngineRow];
            if (slot < 0) slot = 0;
            ether_set_instrument_parameter(etherEngine, slot, static_cast<int>(pid), new_value);
        }

        if (static_cast<int>(pid) != PSEUDO_PARAM_OCTAVE && static_cast<int>(pid) != PSEUDO_PARAM_PITCH) {
            float current_value = engineParameters[latchedEngineRow][static_cast<int>(pid)];
            std::cout << ">>> LATCHED PARAM: " << paramLatches[enc_index].paramName << " (Engine Row " << latchedEngineRow << ") = " << current_value << std::endl;
        }
    } else {
        std::cout << ">>> No parameter latched to encoder " << encoder_id << std::endl;
    }
}

void GridSequencer::handleEncoderButtonPress(int encoder_id) {
    int enc_index = encoder_id - 1; // Convert to 0-3 index
    auto now = std::chrono::steady_clock::now();
    auto time_since_last = std::chrono::duration_cast<std::chrono::milliseconds>(
        now - buttonStates[enc_index].lastPressTime).count();

    if (time_since_last < DOUBLE_PRESS_TIMEOUT_MS && buttonStates[enc_index].pendingSinglePress) {
        // Double press detected
        buttonStates[enc_index].pendingSinglePress = false;
        std::cout << ">>> DOUBLE PRESS: Encoder " << encoder_id << std::endl;

        if (encoder_id == 4) {
            // Encoder 4 double press: could add special behavior
            std::cout << ">>> Encoder 4 double press action" << std::endl;
        } else {
            // Encoders 1-3 double press: clear all latches
            std::cout << ">>> CLEAR ALL LATCHES" << std::endl;
            for (int i = 0; i < 3; i++) {
                paramLatches[i].active = false;
            }
        }
    } else {
        // Potential single press - start timer
        buttonStates[enc_index].pendingSinglePress = true;
        buttonStates[enc_index].lastPressTime = now;
    }
}

void GridSequencer::updateButtonTimers() {
    auto now = std::chrono::steady_clock::now();

    for (int i = 0; i < 4; i++) {
        if (buttonStates[i].pendingSinglePress) {
            auto time_since_press = std::chrono::duration_cast<std::chrono::milliseconds>(
                now - buttonStates[i].lastPressTime).count();

            if (time_since_press >= DOUBLE_PRESS_TIMEOUT_MS) {
                buttonStates[i].pendingSinglePress = false;
                processPendingButtonPress(i + 1); // Convert back to 1-4 encoder ID
            }
        }
    }
}

void GridSequencer::processPendingButtonPress(int encoder_id) {
    std::cout << ">>> SINGLE PRESS: Encoder " << encoder_id << std::endl;

    if (encoder_id == 4) {
        // Encoder 4 single press: toggle edit mode
        editMode = !editMode;
        if (editMode) {
            std::cout << ">>> ENTERED EDIT MODE" << std::endl;
        } else {
            std::cout << ">>> EXITED EDIT MODE" << std::endl;
        }
    } else {
        // Encoders 1-3 single press: latch current parameter
        int enc_index = encoder_id - 1;

        if (selectedParamIndex >= 0 && selectedParamIndex < (int)extendedVisibleParams.size()) {
            int pid = getExtendedParameterId(selectedParamIndex);
                if (pid == -1) return;

                // Allow latching pseudo-parameters with special handling
                if (pid == PSEUDO_PARAM_OCTAVE || pid == PSEUDO_PARAM_PITCH) {
                    paramLatches[enc_index].active = true;
                    paramLatches[enc_index].paramId = static_cast<ParameterID>(pid);
                    paramLatches[enc_index].paramName = (pid == PSEUDO_PARAM_OCTAVE) ? "octave" : "pitch";
                    paramLatches[enc_index].engineRow = currentEngineRow;
                    std::cout << ">>> PSEUDO-PARAM LATCH: Encoder " << encoder_id << " -> " << paramLatches[enc_index].paramName << std::endl;
                    return;
                }
            paramLatches[enc_index].active = true;
            paramLatches[enc_index].paramId = static_cast<ParameterID>(pid);
            paramLatches[enc_index].paramName = getParameterName(static_cast<ParameterID>(pid));
            paramLatches[enc_index].engineRow = currentEngineRow;  // Store which engine this parameter belongs to

            std::cout << ">>> LATCH: Encoder " << encoder_id << " -> " << paramLatches[enc_index].paramName << " (Engine Row " << currentEngineRow << ")" << std::endl;
        } else {
            std::cout << ">>> No parameter selected to latch" << std::endl;
        }
    }
}

int main() {
    GridSequencer sequencer;

    if (!sequencer.initialize()) {
        return 1;
    }

    sequencer.run();
    return 0;
}
